<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Serde</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="help.html"><strong aria-hidden="true">2.</strong> Help</a></li><li class="chapter-item expanded "><a href="data-model.html"><strong aria-hidden="true">3.</strong> Serde data model</a></li><li class="chapter-item expanded "><a href="derive.html"><strong aria-hidden="true">4.</strong> Using derive</a></li><li class="chapter-item expanded "><a href="attributes.html"><strong aria-hidden="true">5.</strong> Attributes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="container-attrs.html"><strong aria-hidden="true">5.1.</strong> Container attributes</a></li><li class="chapter-item expanded "><a href="variant-attrs.html"><strong aria-hidden="true">5.2.</strong> Variant attributes</a></li><li class="chapter-item expanded "><a href="field-attrs.html"><strong aria-hidden="true">5.3.</strong> Field attributes</a></li></ol></li><li class="chapter-item expanded "><a href="custom-serialization.html"><strong aria-hidden="true">6.</strong> Custom serialization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="impl-serialize.html"><strong aria-hidden="true">6.1.</strong> Implementing Serialize</a></li><li class="chapter-item expanded "><a href="impl-deserialize.html"><strong aria-hidden="true">6.2.</strong> Implementing Deserialize</a></li><li class="chapter-item expanded "><a href="unit-testing.html"><strong aria-hidden="true">6.3.</strong> Unit testing</a></li></ol></li><li class="chapter-item expanded "><a href="data-format.html"><strong aria-hidden="true">7.</strong> Writing a data format</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="conventions.html"><strong aria-hidden="true">7.1.</strong> Conventions</a></li><li class="chapter-item expanded "><a href="error-handling.html"><strong aria-hidden="true">7.2.</strong> Error handling</a></li><li class="chapter-item expanded "><a href="impl-serializer.html"><strong aria-hidden="true">7.3.</strong> Implementing a Serializer</a></li><li class="chapter-item expanded "><a href="impl-deserializer.html"><strong aria-hidden="true">7.4.</strong> Implementing a Deserializer</a></li></ol></li><li class="chapter-item expanded "><a href="lifetimes.html"><strong aria-hidden="true">8.</strong> Deserializer lifetimes</a></li><li class="chapter-item expanded "><a href="examples.html"><strong aria-hidden="true">9.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="json.html"><strong aria-hidden="true">9.1.</strong> Structs and enums in JSON</a></li><li class="chapter-item expanded "><a href="enum-representations.html"><strong aria-hidden="true">9.2.</strong> Enum representations</a></li><li class="chapter-item expanded "><a href="attr-default.html"><strong aria-hidden="true">9.3.</strong> Default value for a field</a></li><li class="chapter-item expanded "><a href="attr-flatten.html"><strong aria-hidden="true">9.4.</strong> Struct flattening</a></li><li class="chapter-item expanded "><a href="attr-bound.html"><strong aria-hidden="true">9.5.</strong> Handwritten generic type bounds</a></li><li class="chapter-item expanded "><a href="deserialize-map.html"><strong aria-hidden="true">9.6.</strong> Deserialize for custom map type</a></li><li class="chapter-item expanded "><a href="stream-array.html"><strong aria-hidden="true">9.7.</strong> Array of values without buffering</a></li><li class="chapter-item expanded "><a href="enum-number.html"><strong aria-hidden="true">9.8.</strong> Serialize enum as number</a></li><li class="chapter-item expanded "><a href="attr-rename.html"><strong aria-hidden="true">9.9.</strong> Serialize fields as camelCase</a></li><li class="chapter-item expanded "><a href="attr-skip-serializing.html"><strong aria-hidden="true">9.10.</strong> Skip serializing field</a></li><li class="chapter-item expanded "><a href="remote-derive.html"><strong aria-hidden="true">9.11.</strong> Derive for remote crate</a></li><li class="chapter-item expanded "><a href="deserialize-struct.html"><strong aria-hidden="true">9.12.</strong> Manually deserialize struct</a></li><li class="chapter-item expanded "><a href="ignored-any.html"><strong aria-hidden="true">9.13.</strong> Discarding data</a></li><li class="chapter-item expanded "><a href="transcode.html"><strong aria-hidden="true">9.14.</strong> Transcode into another format</a></li><li class="chapter-item expanded "><a href="string-or-struct.html"><strong aria-hidden="true">9.15.</strong> Either string or struct</a></li><li class="chapter-item expanded "><a href="convert-error.html"><strong aria-hidden="true">9.16.</strong> Convert error types</a></li><li class="chapter-item expanded "><a href="custom-date-format.html"><strong aria-hidden="true">9.17.</strong> Custom date format</a></li></ol></li><li class="chapter-item expanded "><a href="no-std.html"><strong aria-hidden="true">10.</strong> No-std support</a></li><li class="chapter-item expanded "><a href="feature-flags.html"><strong aria-hidden="true">11.</strong> Feature flags</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Serde</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/serde-rs/serde-rs.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <span style="float:right">
  <a href="https://github.com/serde-rs/serde" target="_blank"><img src="img/github.svg" alt="GitHub"></a>
  <a href="https://docs.serde.rs/serde/" target="_blank"><img src="img/rustdoc.svg" alt="rustdoc"></a>
  <a href="https://crates.io/crates/serde" target="_blank"><img src="https://img.shields.io/crates/v/serde.svg?style=social" alt="Latest Version"></a>
</span>
<div style="clear:both"></div>
<h1 id="serde"><a class="header" href="#serde">Serde</a></h1>
<p>Serde is a framework for <em><strong>ser</strong></em>ializing and <em><strong>de</strong></em>serializing Rust data
structures efficiently and generically.</p>
<p>The Serde ecosystem consists of data structures that know how to serialize and
deserialize themselves along with data formats that know how to serialize and
deserialize other things. Serde provides the layer by which these two groups
interact with each other, allowing any supported data structure to be serialized
and deserialized using any supported data format.</p>
<h3 id="design"><a class="header" href="#design">Design</a></h3>
<p>Where many other languages rely on runtime reflection for serializing data,
Serde is instead built on Rust's powerful trait system. A data structure that
knows how to serialize and deserialize itself is one that implements Serde's
<code>Serialize</code> and <code>Deserialize</code> traits (or uses Serde's derive attribute to
automatically generate implementations at compile time). This avoids any
overhead of reflection or runtime type information. In fact in many situations
the interaction between data structure and data format can be completely
optimized away by the Rust compiler, leaving Serde serialization to perform
the same speed as a handwritten serializer for the specific selection of data
structure and data format.</p>
<h3 id="data-formats"><a class="header" href="#data-formats">Data formats</a></h3>
<p>The following is a partial list of data formats that have been implemented for
Serde by the community.</p>
<ul>
<li><a href="https://github.com/serde-rs/json">JSON</a>, the ubiquitous JavaScript Object Notation used by many HTTP APIs.</li>
<li><a href="https://github.com/bincode-org/bincode">Bincode</a>, a compact binary format used for IPC within the Servo rendering
engine.</li>
<li><a href="https://github.com/enarx/ciborium">CBOR</a>, a Concise Binary Object Representation designed for small message size
without the need for version negotiation.</li>
<li><a href="https://github.com/dtolnay/serde-yaml">YAML</a>, a self-proclaimed human-friendly configuration language that ain't
markup language.</li>
<li><a href="https://github.com/3Hren/msgpack-rust">MessagePack</a>, an efficient binary format that resembles a compact JSON.</li>
<li><a href="https://github.com/alexcrichton/toml-rs">TOML</a>, a minimal configuration format used by <a href="http://doc.crates.io/manifest.html">Cargo</a>.</li>
<li><a href="https://github.com/birkenfeld/serde-pickle">Pickle</a>, a format common in the Python world.</li>
<li><a href="https://github.com/ron-rs/ron">RON</a>, a Rusty Object Notation.</li>
<li><a href="https://github.com/mongodb/bson-rust">BSON</a>, the data storage and network transfer format used by MongoDB.</li>
<li><a href="https://github.com/flavray/avro-rs">Avro</a>, a binary format used within Apache Hadoop, with support for schema
definition.</li>
<li><a href="https://github.com/callum-oakley/json5-rs">JSON5</a>, a superset of JSON including some productions from ES5.</li>
<li><a href="https://github.com/jamesmunns/postcard">Postcard</a>, a no_std and embedded-systems friendly compact binary format.</li>
<li><a href="https://docs.rs/serde_qs">URL</a> query strings, in the x-www-form-urlencoded format.</li>
<li><a href="https://github.com/softprops/envy">Envy</a>, a way to deserialize environment variables into Rust structs.
<em>(deserialization only)</em></li>
<li><a href="https://github.com/softprops/envy-store">Envy Store</a>, a way to deserialize <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-parameter-store.html">AWS Parameter Store</a> parameters into Rust
structs. <em>(deserialization only)</em></li>
<li><a href="https://github.com/rotty/lexpr-rs">S-expressions</a>, the textual representation of code and data used by the Lisp
language family.</li>
<li><a href="https://docs.rs/zvariant">D-Bus</a>'s binary wire format.</li>
<li><a href="https://github.com/google/flatbuffers/tree/master/rust/flexbuffers">FlexBuffers</a>, the schemaless cousin of Google's FlatBuffers zero-copy
serialization format.</li>
<li><a href="https://github.com/P3KI/bendy">Bencode</a>, a simple binary format used in the BitTorrent protocol.</li>
<li><a href="https://docs.rs/serde_dynamo">DynamoDB Items</a>, the format used by <a href="https://docs.rs/rusoto_dynamodb">rusoto_dynamodb</a> to transfer data to
and from DynamoDB.</li>
<li><a href="https://github.com/Canop/deser-hjson">Hjson</a>, a syntax extension to JSON designed around human reading and editing.
<em>(deserialization only)</em></li>
</ul>
<h3 id="data-structures"><a class="header" href="#data-structures">Data structures</a></h3>
<p>Out of the box, Serde is able to serialize and deserialize common Rust data
types in any of the above formats. For example <code>String</code>, <code>&amp;str</code>, <code>usize</code>,
<code>Vec&lt;T&gt;</code>, <code>HashMap&lt;K,V&gt;</code> are all supported. In addition, Serde provides a derive
macro to generate serialization implementations for structs in your own program.
Using the derive macro goes like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let point = Point { x: 1, y: 2 };

    // Convert the Point to a JSON string.
    let serialized = serde_json::to_string(&amp;point).unwrap();

    // Prints serialized = {&quot;x&quot;:1,&quot;y&quot;:2}
    println!(&quot;serialized = {}&quot;, serialized);

    // Convert the JSON string back to a Point.
    let deserialized: Point = serde_json::from_str(&amp;serialized).unwrap();

    // Prints deserialized = Point { x: 1, y: 2 }
    println!(&quot;deserialized = {:?}&quot;, deserialized);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-help"><a class="header" href="#getting-help">Getting help</a></h1>
<p>Serde is one of the most widely used Rust libraries so any place that Rustaceans
congregate will be able to help you out. For chat, consider trying the
<a href="https://discord.com/channels/273534239310479360/274215136414400513">#rust-questions</a> or <a href="https://discord.com/channels/273534239310479360/273541522815713281">#rust-beginners</a> channels of the unofficial community
Discord <i>(invite: <a href="https://discord.gg/rust-lang-community">https://discord.gg/rust-lang-community</a>)</i>, the
<a href="https://discord.com/channels/442252698964721669/443150878111694848">#rust-usage</a> or <a href="https://discord.com/channels/442252698964721669/448238009733742612">#beginners</a> channels of the official Rust Project Discord
<i>(invite: <a href="https://discord.gg/rust-lang">https://discord.gg/rust-lang</a>)</i>, or the <a href="https://rust-lang.zulipchat.com/#narrow/stream/122651-general">#general</a> stream
in Zulip. For asynchronous, consider the <a href="https://stackoverflow.com/questions/tagged/rust">[rust] tag on
StackOverflow</a>, the <a href="https://www.reddit.com/r/rust">/r/rust</a> subreddit which has a pinned weekly
easy questions post, or the Rust <a href="https://users.rust-lang.org">Discourse forum</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serde-data-model"><a class="header" href="#serde-data-model">Serde data model</a></h1>
<p>The Serde data model is the API by which data structures and data formats
interact. You can think of it as Serde's type system.</p>
<p>In code, the serialization half of the Serde data model is defined by the
<a href="https://docs.serde.rs/serde/trait.Serializer.html"><code>Serializer</code></a> trait and the deserialization half is defined by the
<a href="https://docs.serde.rs/serde/trait.Deserializer.html"><code>Deserializer</code></a> trait. These are a way of mapping every Rust data structure
into one of 29 possible types. Each method of the <code>Serializer</code> trait corresponds
to one of the types of the data model.</p>
<p>When serializing a data structure to some format, the <a href="https://docs.serde.rs/serde/trait.Serialize.html"><code>Serialize</code></a>
implementation for the data structure is responsible for mapping the data
structure into the Serde data model by invoking exactly one of the <code>Serializer</code>
methods, while the <code>Serializer</code> implementation for the data format is
responsible for mapping the Serde data model into the intended output
representation.</p>
<p>When deserializing a data structure from some format, the <a href="https://docs.serde.rs/serde/trait.Deserialize.html"><code>Deserialize</code></a>
implementation for the data structure is responsible for mapping the data
structure into the Serde data model by passing to the <code>Deserializer</code> a
<a href="https://docs.serde.rs/serde/de/trait.Visitor.html"><code>Visitor</code></a> implementation that can receive the various types of the data model,
while the <code>Deserializer</code> implementation for the data format is responsible for
mapping the input data into the Serde data model by invoking exactly one of the
<code>Visitor</code> methods.</p>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<p>The Serde data model is a simplified form of Rust's type system. It consists of
the following 29 types:</p>
<ul>
<li><strong>14 primitive types</strong>
<ul>
<li>bool</li>
<li>i8, i16, i32, i64, i128</li>
<li>u8, u16, u32, u64, u128</li>
<li>f32, f64</li>
<li>char</li>
</ul>
</li>
<li><strong>string</strong>
<ul>
<li>UTF-8 bytes with a length and no null terminator. May contain 0-bytes.</li>
<li>When serializing, all strings are handled equally. When deserializing, there
are three flavors of strings: transient, owned, and borrowed. This
distinction is explained in <a href="lifetimes.html">Understanding deserializer lifetimes</a> and is a
key way that Serde enabled efficient zero-copy deserialization.</li>
</ul>
</li>
<li><strong>byte array</strong> - [u8]
<ul>
<li>Similar to strings, during deserialization byte arrays can be transient,
owned, or borrowed.</li>
</ul>
</li>
<li><strong>option</strong>
<ul>
<li>Either none or some value.</li>
</ul>
</li>
<li><strong>unit</strong>
<ul>
<li>The type of <code>()</code> in Rust. It represents an anonymous value containing no
data.</li>
</ul>
</li>
<li><strong>unit_struct</strong>
<ul>
<li>For example <code>struct Unit</code> or <code>PhantomData&lt;T&gt;</code>. It represents a named value
containing no data.</li>
</ul>
</li>
<li><strong>unit_variant</strong>
<ul>
<li>For example the <code>E::A</code> and <code>E::B</code> in <code>enum E { A, B }</code>.</li>
</ul>
</li>
<li><strong>newtype_struct</strong>
<ul>
<li>For example <code>struct Millimeters(u8)</code>.</li>
</ul>
</li>
<li><strong>newtype_variant</strong>
<ul>
<li>For example the <code>E::N</code> in <code>enum E { N(u8) }</code>.</li>
</ul>
</li>
<li><strong>seq</strong>
<ul>
<li>A variably sized heterogeneous sequence of values, for example <code>Vec&lt;T&gt;</code> or
<code>HashSet&lt;T&gt;</code>. When serializing, the length may or may not be known before
iterating through all the data. When deserializing, the length is determined
by looking at the serialized data. Note that a homogeneous Rust collection
like <code>vec![Value::Bool(true), Value::Char('c')]</code> may serialize as a
heterogeneous Serde seq, in this case containing a Serde bool followed by a
Serde char.</li>
</ul>
</li>
<li><strong>tuple</strong>
<ul>
<li>A statically sized heterogeneous sequence of values for which the length
will be known at deserialization time without looking at the serialized
data, for example <code>(u8,)</code> or <code>(String, u64, Vec&lt;T&gt;)</code> or <code>[u64; 10]</code>.</li>
</ul>
</li>
<li><strong>tuple_struct</strong>
<ul>
<li>A named tuple, for example <code>struct Rgb(u8, u8, u8)</code>.</li>
</ul>
</li>
<li><strong>tuple_variant</strong>
<ul>
<li>For example the <code>E::T</code> in <code>enum E { T(u8, u8) }</code>.</li>
</ul>
</li>
<li><strong>map</strong>
<ul>
<li>A variably sized heterogeneous key-value pairing, for example <code>BTreeMap&lt;K, V&gt;</code>. When serializing, the length may or may not be known before iterating
through all the entries. When deserializing, the length is determined by
looking at the serialized data.</li>
</ul>
</li>
<li><strong>struct</strong>
<ul>
<li>A statically sized heterogeneous key-value pairing in which the keys are
compile-time constant strings and will be known at deserialization time
without looking at the serialized data, for example <code>struct S { r: u8, g: u8, b: u8 }</code>.</li>
</ul>
</li>
<li><strong>struct_variant</strong>
<ul>
<li>For example the <code>E::S</code> in <code>enum E { S { r: u8, g: u8, b: u8 } }</code>.</li>
</ul>
</li>
</ul>
<h2 id="mapping-into-the-data-model"><a class="header" href="#mapping-into-the-data-model">Mapping into the data model</a></h2>
<p>In the case of most Rust types, their mapping into the Serde data model is
straightforward. For example the Rust <code>bool</code> type corresponds to Serde's bool
type. The Rust tuple struct <code>Rgb(u8, u8, u8)</code> corresponds to Serde's tuple
struct type.</p>
<p>But there is no fundamental reason that these mappings need to be
straightforward. The <a href="https://docs.serde.rs/serde/trait.Serialize.html"><code>Serialize</code></a> and <a href="https://docs.serde.rs/serde/trait.Deserialize.html"><code>Deserialize</code></a> traits can perform <em>any</em>
mapping between Rust type and Serde data model that is appropriate for the use
case.</p>
<p>As an example, consider Rust's <a href="https://doc.rust-lang.org/std/ffi/struct.OsString.html"><code>std::ffi::OsString</code></a> type. This type represents
a platform-native string. On Unix systems they are arbitrary non-zero bytes and
on Windows systems they are arbitrary non-zero 16-bit values. It may seem
natural to map <code>OsString</code> into the Serde data model as one of the following
types:</p>
<ul>
<li>As a Serde <strong>string</strong>. Unfortunately serialization would be brittle because an
<code>OsString</code> is not guaranteed to be representable in UTF-8 and deserialization
would be brittle because Serde strings are allowed to contain 0-bytes.</li>
<li>As a Serde <strong>byte array</strong>. This fixes both problem with using string, but now
if we serialize an <code>OsString</code> on Unix and deserialize it on Windows we end up
with <a href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">the wrong string</a>.</li>
</ul>
<p>Instead the <code>Serialize</code> and <code>Deserialize</code> impls for <code>OsString</code> map into the
Serde data model by treating <code>OsString</code> as a Serde <strong>enum</strong>. Effectively it acts
as though <code>OsString</code> were defined as the following type, even though this does
not match its definition on any individual platform.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(dead_code)]
</span><span class="boring">
</span>enum OsString {
    Unix(Vec&lt;u8&gt;),
    Windows(Vec&lt;u16&gt;),
    // and other platforms
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>The flexibility around mapping into the Serde data model is profound and
powerful. When implementing <code>Serialize</code> and <code>Deserialize</code>, be aware of the
broader context of your type that may make the most instinctive mapping not the
best choice.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-derive"><a class="header" href="#using-derive">Using derive</a></h1>
<p>Serde provides a derive macro to generate implementations of the <code>Serialize</code> and
<code>Deserialize</code> traits for data structures defined in your crate, allowing them to
be represented conveniently in all of Serde's data formats.</p>
<p><strong>You only need to set this up if your code is using <code>#[derive(Serialize, Deserialize)]</code>.</strong></p>
<p>This functionality is based on Rust's <code>#[derive]</code> mechanism, just like what you
would use to automatically derive implementations of the built-in <code>Clone</code>,
<code>Copy</code>, <code>Debug</code>, or other traits. It is able to generate implementations for
most structs and enums including ones with elaborate generic types or trait
bounds. On rare occasions, for an especially convoluted type you may need to
<a href="custom-serialization.html">implement the traits manually</a>.</p>
<p>These derives require a Rust compiler version 1.31 or newer.</p>
<ul>
<li><input disabled="" type="checkbox"/>
Add <code>serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }</code> as a dependency in
Cargo.toml.</li>
<li><input disabled="" type="checkbox"/>
Ensure that all other Serde-based dependencies (for example serde_json) are on
a version that is compatible with serde 1.0.</li>
<li><input disabled="" type="checkbox"/>
On structs and enums that you want to serialize, import the derive macro as
<code>use serde::Serialize;</code> within the same module and write
<code>#[derive(Serialize)]</code> on the struct or enum.</li>
<li><input disabled="" type="checkbox"/>
Similarly import <code>use serde::Deserialize;</code> and write <code>#[derive(Deserialize)]</code>
on structs and enums that you want to deserialize.</li>
</ul>
<p>Here is the <code>Cargo.toml</code>:</p>
<p><strong>Cargo.toml</strong></p>
<pre><code class="language-toml">[package]
name = &quot;my-crate&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Me &lt;user@rust-lang.org&gt;&quot;]

[dependencies]
serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }

# serde_json is just for the example, not required in general
serde_json = &quot;1.0&quot;
</code></pre>
<p>Now the <code>src/main.rs</code> which uses Serde's custom derives:</p>
<p><strong>src/main.rs</strong></p>
<pre><pre class="playground"><code class="language-rust edition2018">use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let point = Point { x: 1, y: 2 };

    let serialized = serde_json::to_string(&amp;point).unwrap();
    println!(&quot;serialized = {}&quot;, serialized);

    let deserialized: Point = serde_json::from_str(&amp;serialized).unwrap();
    println!(&quot;deserialized = {:?}&quot;, deserialized);
}
</code></pre></pre>
<p>Here is the output:</p>
<pre><code>$ cargo run
serialized = {&quot;x&quot;:1,&quot;y&quot;:2}
deserialized = Point { x: 1, y: 2 }
</code></pre>
<h3 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h3>
<p>Sometimes you may see compile-time errors that tell you:</p>
<pre><code>the trait `serde::ser::Serialize` is not implemented for `...`
</code></pre>
<p>even though the struct or enum clearly has <code>#[derive(Serialize)]</code> on it.</p>
<p>This almost always means that you are using libraries that depend on
incompatible versions of Serde. You may be depending on serde 1.0 in your
Cargo.toml but using some other library that depends on serde 0.9. So the
<code>Serialize</code> trait from serde 1.0 may be implemented, but the library expects an
implementation of the <code>Serialize</code> trait from serde 0.9. From the Rust compiler's
perspective these are totally different traits.</p>
<p>The fix is to upgrade or downgrade libraries as appropriate until the Serde
versions match. The <code>cargo tree -d</code> command is helpful for finding all the
places that duplicate dependencies are being pulled in.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attributes"><a class="header" href="#attributes">Attributes</a></h1>
<p><a href="https://doc.rust-lang.org/book/attributes.html">Attributes</a> are used to customize the <code>Serialize</code> and <code>Deserialize</code>
implementations produced by Serde's derive. They require a Rust compiler version
1.15 or newer.</p>
<p>There are three categories of attributes:</p>
<ul>
<li><a href="container-attrs.html"><strong>Container attributes</strong></a> — apply to a struct or enum declaration.</li>
<li><a href="variant-attrs.html"><strong>Variant attributes</strong></a> — apply to a variant of an enum.</li>
<li><a href="field-attrs.html"><strong>Field attributes</strong></a> — apply to one field in a struct or in an enum variant.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">use serde::{Serialize, Deserialize};
</span><span class="boring">
</span>#[derive(Serialize, Deserialize)]
#[serde(deny_unknown_fields)]  // &lt;-- this is a container attribute
struct S {
    #[serde(default)]  // &lt;-- this is a field attribute
    f: i32,
}

#[derive(Serialize, Deserialize)]
#[serde(rename = &quot;e&quot;)]  // &lt;-- this is also a container attribute
enum E {
    #[serde(rename = &quot;a&quot;)]  // &lt;-- this is a variant attribute
    A(String),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Note that a single struct, enum, variant, or field may have multiple attributes
on it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="container-attributes"><a class="header" href="#container-attributes">Container attributes</a></h1>
<ul>
<li>
<h5 id="serderename--name-rename"><a class="header" href="#serderename--name-rename"><code>#[serde(rename = &quot;name&quot;)]</code> {#rename}</a></h5>
<p>Serialize and deserialize this struct or enum with the given name instead of
its Rust name.</p>
<p>Allows specifying independent names for serialization vs deserialization:</p>
<ul>
<li><code>#[serde(rename(serialize = &quot;ser_name&quot;))]</code></li>
<li><code>#[serde(rename(deserialize = &quot;de_name&quot;))]</code></li>
<li><code>#[serde(rename(serialize = &quot;ser_name&quot;, deserialize = &quot;de_name&quot;))]</code></li>
</ul>
</li>
<li>
<h5 id="serderename_all---rename_all"><a class="header" href="#serderename_all---rename_all"><code>#[serde(rename_all = &quot;...&quot;)]</code> {#rename_all}</a></h5>
<p>Rename all the fields (if this is a struct) or variants (if this is an enum)
according to the given case convention. The possible values are <code>&quot;lowercase&quot;</code>,
<code>&quot;UPPERCASE&quot;</code>, <code>&quot;PascalCase&quot;</code>, <code>&quot;camelCase&quot;</code>, <code>&quot;snake_case&quot;</code>,
<code>&quot;SCREAMING_SNAKE_CASE&quot;</code>, <code>&quot;kebab-case&quot;</code>, <code>&quot;SCREAMING-KEBAB-CASE&quot;</code>.</p>
<p>Allows specifying independent cases for serialization vs deserialization:</p>
<ul>
<li><code>#[serde(rename_all(serialize = &quot;...&quot;))]</code></li>
<li><code>#[serde(rename_all(deserialize = &quot;...&quot;))]</code></li>
<li><code>#[serde(rename_all(serialize = &quot;...&quot;, deserialize = &quot;...&quot;))]</code></li>
</ul>
</li>
<li>
<h5 id="serdedeny_unknown_fields-deny_unknown_fields"><a class="header" href="#serdedeny_unknown_fields-deny_unknown_fields"><code>#[serde(deny_unknown_fields)]</code> {#deny_unknown_fields}</a></h5>
<p>Always error during deserialization when encountering unknown fields. When
this attribute is not present, by default unknown fields are ignored for
self-describing formats like JSON.</p>
<p><em>Note:</em> this attribute is not supported in combination with <a href="field-attrs.html#flatten"><code>flatten</code></a>,
neither on the outer struct nor on the flattened field.</p>
</li>
<li>
<h5 id="serdetag--type-tag"><a class="header" href="#serdetag--type-tag"><code>#[serde(tag = &quot;type&quot;)]</code> {#tag}</a></h5>
<p>Use the internally tagged enum representation for this enum, with the given
tag. See <a href="enum-representations.html">enum representations</a> for details on this
representation.</p>
</li>
<li>
<h5 id="serdetag--t-content--c-tag--content"><a class="header" href="#serdetag--t-content--c-tag--content"><code>#[serde(tag = &quot;t&quot;, content = &quot;c&quot;)]</code> {#tag--content}</a></h5>
<p>Use the adjacently tagged enum representation for this enum, with the given
field names for the tag and content. See <a href="enum-representations.html">enum
representations</a> for details on this representation.</p>
</li>
<li>
<h5 id="serdeuntagged-untagged"><a class="header" href="#serdeuntagged-untagged"><code>#[serde(untagged)]</code> {#untagged}</a></h5>
<p>Use the untagged enum representation for this enum. See <a href="enum-representations.html">enum
representations</a> for details on this representation.</p>
</li>
<li>
<h5 id="serdebound--t-mytrait-bound"><a class="header" href="#serdebound--t-mytrait-bound"><code>#[serde(bound = &quot;T: MyTrait&quot;)]</code> {#bound}</a></h5>
<p>Where-clause for the <code>Serialize</code> and <code>Deserialize</code> impls. This replaces any
trait bounds inferred by Serde.</p>
<p>Allows specifying independent bounds for serialization vs deserialization:</p>
<ul>
<li><code>#[serde(bound(serialize = &quot;T: MySerTrait&quot;))]</code></li>
<li><code>#[serde(bound(deserialize = &quot;T: MyDeTrait&quot;))]</code></li>
<li><code>#[serde(bound(serialize = &quot;T: MySerTrait&quot;, deserialize = &quot;T: MyDeTrait&quot;))]</code></li>
</ul>
</li>
<li>
<h5 id="serdedefault-default"><a class="header" href="#serdedefault-default"><code>#[serde(default)]</code> {#default}</a></h5>
<p>When deserializing, any missing fields should be filled in from the struct's
implementation of <code>Default</code>. Only allowed on structs.</p>
</li>
<li>
<h5 id="serdedefault--path-default--path"><a class="header" href="#serdedefault--path-default--path"><code>#[serde(default = &quot;path&quot;)]</code> {#default--path}</a></h5>
<p>When deserializing, any missing fields should be filled in from the object
returned by the given function or method. The function must be callable as
<code>fn() -&gt; T</code>. For example <code>default = &quot;my_default&quot;</code> would invoke <code>my_default()</code>
and <code>default = &quot;SomeTrait::some_default&quot;</code> would invoke
<code>SomeTrait::some_default()</code>. Only allowed on structs.</p>
</li>
<li>
<h5 id="serderemote---remote"><a class="header" href="#serderemote---remote"><code>#[serde(remote = &quot;...&quot;)]</code> {#remote}</a></h5>
<p>This is used for deriving <code>Serialize</code> and <code>Deserialize</code> for <a href="remote-derive.html">remote
types</a>.</p>
</li>
<li>
<h5 id="serdetransparent-transparent"><a class="header" href="#serdetransparent-transparent"><code>#[serde(transparent)]</code> {#transparent}</a></h5>
<p>Serialize and deserialize a newtype struct or a braced struct with one field
exactly the same as if its one field were serialized and deserialized by
itself. Analogous to <code>#[repr(transparent)]</code>.</p>
</li>
<li>
<h5 id="serdefrom--fromtype-from"><a class="header" href="#serdefrom--fromtype-from"><code>#[serde(from = &quot;FromType&quot;)]</code> {#from}</a></h5>
<p>Deserialize this type by deserializing into <code>FromType</code>, then converting. This
type must implement <code>From&lt;FromType&gt;</code>, and <code>FromType</code> must implement
<code>Deserialize</code>.</p>
</li>
<li>
<h5 id="serdetry_from--fromtype-try_from"><a class="header" href="#serdetry_from--fromtype-try_from"><code>#[serde(try_from = &quot;FromType&quot;)]</code> {#try_from}</a></h5>
<p>Deserialize this type by deserializing into <code>FromType</code>, then converting
fallibly. This type must implement <code>TryFrom&lt;FromType&gt;</code> with an error type that
implements <code>Display</code>, and <code>FromType</code> must implement <code>Deserialize</code>.</p>
</li>
<li>
<h5 id="serdeinto--intotype-into"><a class="header" href="#serdeinto--intotype-into"><code>#[serde(into = &quot;IntoType&quot;)]</code> {#into}</a></h5>
<p>Serialize this type by converting it into the specified <code>IntoType</code> and
serializing that. This type must implement <code>Clone</code> and <code>Into&lt;IntoType&gt;</code>, and
<code>IntoType</code> must implement <code>Serialize</code>.</p>
</li>
<li>
<h5 id="serdecrate---crate"><a class="header" href="#serdecrate---crate"><code>#[serde(crate = &quot;...&quot;)]</code> {#crate}</a></h5>
<p>Specify a path to the <code>serde</code> crate instance to use when referring to Serde
APIs from generated code. This is normally only applicable when invoking
re-exported Serde derives from a public macro in a different crate.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variant-attributes"><a class="header" href="#variant-attributes">Variant attributes</a></h1>
<ul>
<li>
<h5 id="serderename--name-rename-1"><a class="header" href="#serderename--name-rename-1"><code>#[serde(rename = &quot;name&quot;)]</code> {#rename}</a></h5>
<p>Serialize and deserialize this variant with the given name instead of its Rust
name.</p>
<p>Allows specifying independent names for serialization vs deserialization:</p>
<ul>
<li><code>#[serde(rename(serialize = &quot;ser_name&quot;))]</code></li>
<li><code>#[serde(rename(deserialize = &quot;de_name&quot;))]</code></li>
<li><code>#[serde(rename(serialize = &quot;ser_name&quot;, deserialize = &quot;de_name&quot;))]</code></li>
</ul>
</li>
<li>
<h5 id="serdealias--name-alias"><a class="header" href="#serdealias--name-alias"><code>#[serde(alias = &quot;name&quot;)]</code> {#alias}</a></h5>
<p>Deserialize this variant from the given name <em>or</em> from its Rust name. May be
repeated to specify multiple possible names for the same variant.</p>
</li>
<li>
<h5 id="serderename_all---rename_all-1"><a class="header" href="#serderename_all---rename_all-1"><code>#[serde(rename_all = &quot;...&quot;)]</code> {#rename_all}</a></h5>
<p>Rename all the fields of this struct variant according to the given case
convention. The possible values are <code>&quot;lowercase&quot;</code>, <code>&quot;UPPERCASE&quot;</code>,
<code>&quot;PascalCase&quot;</code>, <code>&quot;camelCase&quot;</code>, <code>&quot;snake_case&quot;</code>, <code>&quot;SCREAMING_SNAKE_CASE&quot;</code>,
<code>&quot;kebab-case&quot;</code>, <code>&quot;SCREAMING-KEBAB-CASE&quot;</code>.</p>
<p>Allows specifying independent cases for serialization vs deserialization:</p>
<ul>
<li><code>#[serde(rename_all(serialize = &quot;...&quot;))]</code></li>
<li><code>#[serde(rename_all(deserialize = &quot;...&quot;))]</code></li>
<li><code>#[serde(rename_all(serialize = &quot;...&quot;, deserialize = &quot;...&quot;))]</code></li>
</ul>
</li>
<li>
<h5 id="serdeskip-skip"><a class="header" href="#serdeskip-skip"><code>#[serde(skip)]</code> {#skip}</a></h5>
<p>Never serialize or deserialize this variant.</p>
</li>
<li>
<h5 id="serdeskip_serializing-skip_serializing"><a class="header" href="#serdeskip_serializing-skip_serializing"><code>#[serde(skip_serializing)]</code> {#skip_serializing}</a></h5>
<p>Never serialize this variant. Trying to serialize this variant is treated as
an error.</p>
</li>
<li>
<h5 id="serdeskip_deserializing-skip_deserializing"><a class="header" href="#serdeskip_deserializing-skip_deserializing"><code>#[serde(skip_deserializing)]</code> {#skip_deserializing}</a></h5>
<p>Never deserialize this variant.</p>
</li>
<li>
<h5 id="serdeserialize_with--path-serialize_with"><a class="header" href="#serdeserialize_with--path-serialize_with"><code>#[serde(serialize_with = &quot;path&quot;)]</code> {#serialize_with}</a></h5>
<p>Serialize this variant using a function that is different from its
implementation of <code>Serialize</code>. The given function must be callable as
<code>fn&lt;S&gt;(&amp;FIELD0, &amp;FIELD1, ..., S) -&gt; Result&lt;S::Ok, S::Error&gt; where S: Serializer</code>, although it may also be generic over the <code>FIELD{n}</code> types.
Variants used with <code>serialize_with</code> are not required to be able to derive
<code>Serialize</code>.</p>
<p><code>FIELD{n}</code> exists for every field of the variant. So a unit variant has just
the <code>S</code> argument, and tuple/struct variants have an argument for every field.</p>
</li>
<li>
<h5 id="serdedeserialize_with--path-deserialize_with"><a class="header" href="#serdedeserialize_with--path-deserialize_with"><code>#[serde(deserialize_with = &quot;path&quot;)]</code> {#deserialize_with}</a></h5>
<p>Deserialize this variant using a function that is different from its
implementation of <code>Deserialize</code>. The given function must be callable as
<code>fn&lt;'de, D&gt;(D) -&gt; Result&lt;FIELDS, D::Error&gt; where D: Deserializer&lt;'de&gt;</code>,
although it may also be generic over the elements of <code>FIELDS</code>. Variants used
with <code>deserialize_with</code> are not required be able to derive <code>Deserialize</code>.</p>
<p><code>FIELDS</code> is a tuple of all fields of the variant. A unit variant will have
<code>()</code> as its <code>FIELDS</code> type.</p>
</li>
<li>
<h5 id="serdewith--module-with"><a class="header" href="#serdewith--module-with"><code>#[serde(with = &quot;module&quot;)]</code> {#with}</a></h5>
<p>Combination of <code>serialize_with</code> and <code>deserialize_with</code>. Serde will use
<code>$module::serialize</code> as the <code>serialize_with</code> function and
<code>$module::deserialize</code> as the <code>deserialize_with</code> function.</p>
</li>
<li>
<h5 id="serdebound--t-mytrait-bound-1"><a class="header" href="#serdebound--t-mytrait-bound-1"><code>#[serde(bound = &quot;T: MyTrait&quot;)]</code> {#bound}</a></h5>
<p>Where-clause for the <code>Serialize</code> and/or <code>Deserialize</code> impls. This replaces any
trait bounds inferred by Serde for the current variant.</p>
<p>Allows specifying independent bounds for serialization vs deserialization:</p>
<ul>
<li><code>#[serde(bound(serialize = &quot;T: MySerTrait&quot;))]</code></li>
<li><code>#[serde(bound(deserialize = &quot;T: MyDeTrait&quot;))]</code></li>
<li><code>#[serde(bound(serialize = &quot;T: MySerTrait&quot;, deserialize = &quot;T: MyDeTrait&quot;))]</code></li>
</ul>
</li>
<li>
<h5 id="serdeborrow-and-serdeborrow--a--b---borrow"><a class="header" href="#serdeborrow-and-serdeborrow--a--b---borrow"><code>#[serde(borrow)]</code> and <code>#[serde(borrow = &quot;'a + 'b + ...&quot;)]</code> {#borrow}</a></h5>
<p>Borrow data for this field from the deserializer by using zero-copy
deserialization. See <a href="lifetimes.html#borrowing-data-in-a-derived-impl">this example</a>.
Only allowed on a newtype variant (a tuple variant with only one field).</p>
</li>
<li>
<h5 id="serdeother-other"><a class="header" href="#serdeother-other"><code>#[serde(other)]</code> {#other}</a></h5>
<p>Deserialize this variant if the enum tag is anything other than the tag of one
of the other variants in this enum. Only allowed on a unit variant inside of
an internally tagged or adjacently tagged enum.</p>
<p>For example if we have an internally tagged enum with <code>serde(tag = &quot;variant&quot;)</code>
containing variants <code>A</code>, <code>B</code>, and <code>Unknown</code> marked <code>serde(other)</code>, the
<code>Unknown</code> variant would be deserialized any time the <code>&quot;variant&quot;</code> field of the
input is neither <code>&quot;A&quot;</code> nor <code>&quot;B&quot;</code>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="field-attributes"><a class="header" href="#field-attributes">Field attributes</a></h1>
<ul>
<li>
<h5 id="serderename--name-rename-2"><a class="header" href="#serderename--name-rename-2"><code>#[serde(rename = &quot;name&quot;)]</code> {#rename}</a></h5>
<p>Serialize and deserialize this field with the given name instead of its Rust
name. This is useful for <a href="attr-rename.html">serializing fields as camelCase</a> or
serializing fields with names that are reserved Rust keywords.</p>
<p>Allows specifying independent names for serialization vs deserialization:</p>
<ul>
<li><code>#[serde(rename(serialize = &quot;ser_name&quot;))]</code></li>
<li><code>#[serde(rename(deserialize = &quot;de_name&quot;))]</code></li>
<li><code>#[serde(rename(serialize = &quot;ser_name&quot;, deserialize = &quot;de_name&quot;))]</code></li>
</ul>
</li>
<li>
<h5 id="serdealias--name-alias-1"><a class="header" href="#serdealias--name-alias-1"><code>#[serde(alias = &quot;name&quot;)]</code> {#alias}</a></h5>
<p>Deserialize this field from the given name <em>or</em> from its Rust name. May be
repeated to specify multiple possible names for the same field.</p>
</li>
<li>
<h5 id="serdedefault-default-1"><a class="header" href="#serdedefault-default-1"><code>#[serde(default)]</code> {#default}</a></h5>
<p>If the value is not present when deserializing, use the <code>Default::default()</code>.</p>
</li>
<li>
<h5 id="serdedefault--path-default--path-1"><a class="header" href="#serdedefault--path-default--path-1"><code>#[serde(default = &quot;path&quot;)]</code> {#default--path}</a></h5>
<p>If the value is not present when deserializing, call a function to get a
default value. The given function must be callable as <code>fn() -&gt; T</code>. For example
<code>default = &quot;empty_value&quot;</code> would invoke <code>empty_value()</code> and <code>default = &quot;SomeTrait::some_default&quot;</code> would invoke <code>SomeTrait::some_default()</code>.</p>
</li>
<li>
<h5 id="serdeflatten-flatten"><a class="header" href="#serdeflatten-flatten"><code>#[serde(flatten)]</code> {#flatten}</a></h5>
<p>Flatten the contents of this field into the container it is defined in.</p>
<p>This removes one level of structure between the serialized representation and
the Rust data structure representation. It can be used for factoring common
keys into a shared structure, or for capturing remaining fields into a map
with arbitrary string keys. The <a href="attr-flatten.html">struct flattening</a> page
provides some examples.</p>
<p><em>Note:</em> this attribute is not supported in combination with structs that use
<a href="container-attrs.html#deny_unknown_fields"><code>deny_unknown_fields</code></a>. Neither the outer nor inner flattened struct should
use that attribute.</p>
</li>
<li>
<h5 id="serdeskip-skip-1"><a class="header" href="#serdeskip-skip-1"><code>#[serde(skip)]</code> {#skip}</a></h5>
<p>Skip this field: do not serialize or deserialize it.</p>
<p>When deserializing, Serde will use <code>Default::default()</code> or the function
given by <code>default = &quot;...&quot;</code> to get a default value for this field.</p>
</li>
<li>
<h5 id="serdeskip_serializing-skip_serializing-1"><a class="header" href="#serdeskip_serializing-skip_serializing-1"><code>#[serde(skip_serializing)]</code> {#skip_serializing}</a></h5>
<p>Skip this field when serializing, but not when deserializing.</p>
</li>
<li>
<h5 id="serdeskip_deserializing-skip_deserializing-1"><a class="header" href="#serdeskip_deserializing-skip_deserializing-1"><code>#[serde(skip_deserializing)]</code> {#skip_deserializing}</a></h5>
<p>Skip this field when deserializing, but not when serializing.</p>
<p>When deserializing, Serde will use <code>Default::default()</code> or the function
given by <code>default = &quot;...&quot;</code> to get a default value for this field.</p>
</li>
<li>
<h5 id="serdeskip_serializing_if--path-skip_serializing_if"><a class="header" href="#serdeskip_serializing_if--path-skip_serializing_if"><code>#[serde(skip_serializing_if = &quot;path&quot;)]</code> {#skip_serializing_if}</a></h5>
<p>Call a function to determine whether to skip serializing this field. The given
function must be callable as <code>fn(&amp;T) -&gt; bool</code>, although it may be generic over
<code>T</code>. For example <code>skip_serializing_if = &quot;Option::is_none&quot;</code> would skip an
Option that is None.</p>
</li>
<li>
<h5 id="serdeserialize_with--path-serialize_with-1"><a class="header" href="#serdeserialize_with--path-serialize_with-1"><code>#[serde(serialize_with = &quot;path&quot;)]</code> {#serialize_with}</a></h5>
<p>Serialize this field using a function that is different from its
implementation of <code>Serialize</code>. The given function must be callable as
<code>fn&lt;S&gt;(&amp;T, S) -&gt; Result&lt;S::Ok, S::Error&gt; where S: Serializer</code>, although it
may also be generic over <code>T</code>. Fields used with <code>serialize_with</code> are not
required to implement <code>Serialize</code>.</p>
</li>
<li>
<h5 id="serdedeserialize_with--path-deserialize_with-1"><a class="header" href="#serdedeserialize_with--path-deserialize_with-1"><code>#[serde(deserialize_with = &quot;path&quot;)]</code> {#deserialize_with}</a></h5>
<p>Deserialize this field using a function that is different from its
implementation of <code>Deserialize</code>. The given function must be callable as
<code>fn&lt;'de, D&gt;(D) -&gt; Result&lt;T, D::Error&gt; where D: Deserializer&lt;'de&gt;</code>, although it
may also be generic over <code>T</code>. Fields used with <code>deserialize_with</code> are not
required to implement <code>Deserialize</code>.</p>
</li>
<li>
<h5 id="serdewith--module-with-1"><a class="header" href="#serdewith--module-with-1"><code>#[serde(with = &quot;module&quot;)]</code> {#with}</a></h5>
<p>Combination of <code>serialize_with</code> and <code>deserialize_with</code>. Serde will use
<code>$module::serialize</code> as the <code>serialize_with</code> function and
<code>$module::deserialize</code> as the <code>deserialize_with</code> function.</p>
</li>
<li>
<h5 id="serdeborrow-and-serdeborrow--a--b---borrow-1"><a class="header" href="#serdeborrow-and-serdeborrow--a--b---borrow-1"><code>#[serde(borrow)]</code> and <code>#[serde(borrow = &quot;'a + 'b + ...&quot;)]</code> {#borrow}</a></h5>
<p>Borrow data for this field from the deserializer by using zero-copy
deserialization. See <a href="lifetimes.html#borrowing-data-in-a-derived-impl">this example</a>.</p>
</li>
<li>
<h5 id="serdebound--t-mytrait-bound-2"><a class="header" href="#serdebound--t-mytrait-bound-2"><code>#[serde(bound = &quot;T: MyTrait&quot;)]</code> {#bound}</a></h5>
<p>Where-clause for the <code>Serialize</code> and <code>Deserialize</code> impls. This replaces any
trait bounds inferred by Serde for the current field.</p>
<p>Allows specifying independent bounds for serialization vs deserialization:</p>
<ul>
<li><code>#[serde(bound(serialize = &quot;T: MySerTrait&quot;))]</code></li>
<li><code>#[serde(bound(deserialize = &quot;T: MyDeTrait&quot;))]</code></li>
<li><code>#[serde(bound(serialize = &quot;T: MySerTrait&quot;, deserialize = &quot;T: MyDeTrait&quot;))]</code></li>
</ul>
</li>
<li>
<h5 id="serdegetter---getter"><a class="header" href="#serdegetter---getter"><code>#[serde(getter = &quot;...&quot;)]</code> {#getter}</a></h5>
<p>This is used when deriving <code>Serialize</code> for a <a href="remote-derive.html">remote type</a>
that has one or more private fields.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-serialization"><a class="header" href="#custom-serialization">Custom serialization</a></h1>
<p>Serde's <a href="derive.html">derive macro</a> through <code>#[derive(Serialize, Deserialize)]</code>
provides reasonable default serialization behavior for structs and enums and it
can be customized to some extent using <a href="attributes.html">attributes</a>. For unusual
needs, Serde allows full customization of the serialization behavior by manually
implementing <a href="https://docs.serde.rs/serde/ser/trait.Serialize.html"><code>Serialize</code></a>
and <a href="https://docs.serde.rs/serde/de/trait.Deserialize.html"><code>Deserialize</code></a>
traits for your type.</p>
<p>The traits each have a single method:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">use serde::{Serializer, Deserializer};
</span><span class="boring">
</span>pub trait Serialize {
    fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;
    where
        S: Serializer;
}

pub trait Deserialize&lt;'de&gt;: Sized {
    fn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Self, D::Error&gt;
    where
        D: Deserializer&lt;'de&gt;;
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>These methods are generic over the serialization format, represented by the
<a href="https://docs.serde.rs/serde/ser/trait.Serializer.html"><code>Serializer</code></a> and
<a href="https://docs.serde.rs/serde/de/trait.Deserializer.html"><code>Deserializer</code></a> traits.
For example there is one Serializer type for JSON and a different one for
Bincode.</p>
<ul>
<li><a href="impl-serialize.html">Implementing <code>Serialize</code></a></li>
<li><a href="impl-deserialize.html">Implementing <code>Deserialize</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-serialize"><a class="header" href="#implementing-serialize">Implementing Serialize</a></h1>
<p>The <a href="https://docs.serde.rs/serde/ser/trait.Serialize.html"><code>Serialize</code></a> trait looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">use serde::Serializer;
</span><span class="boring">
</span>pub trait Serialize {
    fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;
    where
        S: Serializer;
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>This method's job is to take your type (<code>&amp;self</code>) and map it into the <a href="data-model.html">Serde data
model</a> by invoking exactly one of the methods on the given <a href="https://docs.serde.rs/serde/ser/trait.Serializer.html"><code>Serializer</code></a>.</p>
<p>In most cases Serde's <a href="derive.html">derive</a> is able to generate an appropriate implementation
of <code>Serialize</code> for structs and enums defined in your crate. Should you need to
customize the serialization behavior for a type in a way that derive does not
support, you can implement <code>Serialize</code> yourself.</p>
<h2 id="serializing-a-primitive"><a class="header" href="#serializing-a-primitive">Serializing a primitive</a></h2>
<p>As the simplest example, here is the builtin <code>Serialize</code> impl for the primitive
<code>i32</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">use std::os::raw::c_int as ActualI32;
</span><span class="boring">
</span><span class="boring">use serde::{Serialize, Serializer};
</span><span class="boring">
</span><span class="boring">#[allow(dead_code, non_camel_case_types)]
</span><span class="boring">struct i32;
</span><span class="boring">
</span><span class="boring">trait Serialize2 {
</span><span class="boring">    fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;
</span><span class="boring">    where
</span><span class="boring">        S: Serializer;
</span><span class="boring">}
</span><span class="boring">
</span>impl Serialize for i32 {
    fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;
    where
        S: Serializer,
    {
<span class="boring">        impl Serialize2 for ActualI32 {
</span><span class="boring">            fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;
</span><span class="boring">            where
</span><span class="boring">                S: Serializer,
</span><span class="boring">            {
</span>        serializer.serialize_i32(*self)
<span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let _ = serializer;
</span><span class="boring">        unimplemented!()
</span>    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Serde provides such impls for all of Rust's <a href="https://doc.rust-lang.org/book/primitive-types.html">primitive types</a> so you are not
responsible for implementing them yourself, but <code>serialize_i32</code> and similar
methods may be useful if you have a type that needs to be represented as a
primitive in its serialized form. For example you could <a href="https://serde.rs/enum-number.html">serialize a C-like enum
as a primitive number</a>.</p>
<h2 id="serializing-a-sequence-or-map"><a class="header" href="#serializing-a-sequence-or-map">Serializing a sequence or map</a></h2>
<p>Compound types follow a three-step process of init, elements, end.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">use std::marker::PhantomData;
</span><span class="boring">
</span><span class="boring">struct Vec&lt;T&gt;(PhantomData&lt;T&gt;);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Vec&lt;T&gt; {
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; IntoIterator for &amp;'a Vec&lt;T&gt; {
</span><span class="boring">    type Item = &amp;'a T;
</span><span class="boring">    type IntoIter = Box&lt;dyn Iterator&lt;Item = &amp;'a T&gt;&gt;;
</span><span class="boring">
</span><span class="boring">    fn into_iter(self) -&gt; Self::IntoIter {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyMap&lt;K, V&gt;(PhantomData&lt;K&gt;, PhantomData&lt;V&gt;);
</span><span class="boring">
</span><span class="boring">impl&lt;K, V&gt; MyMap&lt;K, V&gt; {
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, K, V&gt; IntoIterator for &amp;'a MyMap&lt;K, V&gt; {
</span><span class="boring">    type Item = (&amp;'a K, &amp;'a V);
</span><span class="boring">    type IntoIter = Box&lt;dyn Iterator&lt;Item = (&amp;'a K, &amp;'a V)&gt;&gt;;
</span><span class="boring">
</span><span class="boring">    fn into_iter(self) -&gt; Self::IntoIter {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use serde::ser::{Serialize, Serializer, SerializeSeq, SerializeMap};

impl&lt;T&gt; Serialize for Vec&lt;T&gt;
where
    T: Serialize,
{
    fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self {
            seq.serialize_element(e)?;
        }
        seq.end()
    }
}

impl&lt;K, V&gt; Serialize for MyMap&lt;K, V&gt;
where
    K: Serialize,
    V: Serialize,
{
    fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;
    where
        S: Serializer,
    {
        let mut map = serializer.serialize_map(Some(self.len()))?;
        for (k, v) in self {
            map.serialize_entry(k, v)?;
        }
        map.end()
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="serializing-a-tuple"><a class="header" href="#serializing-a-tuple">Serializing a tuple</a></h2>
<p>The <code>serialize_tuple</code> method is a lot like <code>serialize_seq</code>. The distinction
Serde makes is that <code>serialize_tuple</code> is for sequences where the length does not
need to be serialized because it will be known at deserialization time. The
usual examples are Rust <a href="https://doc.rust-lang.org/std/primitive.tuple.html">tuples</a> and <a href="https://doc.rust-lang.org/std/primitive.array.html">arrays</a>. In non-self-describing formats a
<code>Vec&lt;T&gt;</code> needs to be serialized with its length in order to be able to
deserialize a <code>Vec&lt;T&gt;</code> back out. But a <code>[T; 16]</code> can be serialized using
<code>serialize_tuple</code> because the length will be known at deserialization time
without looking at the serialized bytes.</p>
<h2 id="serializing-a-struct"><a class="header" href="#serializing-a-struct">Serializing a struct</a></h2>
<p>Serde distinguishes between four types of structs. <a href="https://doc.rust-lang.org/book/structs.html">Ordinary structs</a> and <a href="https://doc.rust-lang.org/book/structs.html#tuple-structs">tuple
structs</a> follow the three-step process of init, elements, end just like a
sequence or map. <a href="https://doc.rust-lang.org/book/structs.html#tuple-structs">Newtype structs</a> and <a href="https://doc.rust-lang.org/book/structs.html#unit-like-structs">unit structs</a> are more like primitives.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(dead_code)]
</span><span class="boring">
</span>// An ordinary struct. Use three-step process:
//   1. serialize_struct
//   2. serialize_field
//   3. end
struct Color {
    r: u8,
    g: u8,
    b: u8,
}

// A tuple struct. Use three-step process:
//   1. serialize_tuple_struct
//   2. serialize_field
//   3. end
struct Point2D(f64, f64);

// A newtype struct. Use serialize_newtype_struct.
struct Inches(u64);

// A unit struct. Use serialize_unit_struct.
struct Instance;
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Structs and maps may look similar in some formats, including JSON. The
distinction Serde makes is that structs have keys that are compile-time constant
strings and will be known at deserialization time without looking at the
serialized data. This condition enables some data formats to handle structs much
more efficiently and compactly than maps.</p>
<p>Data formats are encouraged to treat newtype structs as insignificant wrappers
around the inner value, serializing just the inner value. See for example
<a href="json.html">JSON's treatment of newtype structs</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(dead_code)]
</span><span class="boring">
</span>use serde::ser::{Serialize, Serializer, SerializeStruct};

struct Color {
    r: u8,
    g: u8,
    b: u8,
}

impl Serialize for Color {
    fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;
    where
        S: Serializer,
    {
        // 3 is the number of fields in the struct.
        let mut state = serializer.serialize_struct(&quot;Color&quot;, 3)?;
        state.serialize_field(&quot;r&quot;, &amp;self.r)?;
        state.serialize_field(&quot;g&quot;, &amp;self.g)?;
        state.serialize_field(&quot;b&quot;, &amp;self.b)?;
        state.end()
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="serializing-an-enum"><a class="header" href="#serializing-an-enum">Serializing an enum</a></h2>
<p>Serializing enum variants is very similar to serializing structs.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#[allow(dead_code)]
</span>enum E {
    // Use three-step process:
    //   1. serialize_struct_variant
    //   2. serialize_field
    //   3. end
    Color { r: u8, g: u8, b: u8 },

    // Use three-step process:
    //   1. serialize_tuple_variant
    //   2. serialize_field
    //   3. end
    Point2D(f64, f64),

    // Use serialize_newtype_variant.
    Inches(u64),

    // Use serialize_unit_variant.
    Instance,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="other-special-cases"><a class="header" href="#other-special-cases">Other special cases</a></h2>
<p>There are two more special cases that are part of the Serializer trait.</p>
<p>There is a method <code>serialize_bytes</code> which serializes a <code>&amp;[u8]</code>. Some formats
treat bytes like any other seq, but some formats are able to serialize bytes
more compactly. Currently Serde does not use <code>serialize_bytes</code> in the
<code>Serialize</code> impl for <code>&amp;[u8]</code> or <code>Vec&lt;u8&gt;</code> but once <a href="https://github.com/rust-lang/rust/issues/31844">specialization</a> lands in
stable Rust we will begin using it. For now the <a href="https://docs.serde.rs/serde_bytes/"><code>serde_bytes</code></a> crate can be
used to enable efficient handling of <code>&amp;[u8]</code> and <code>Vec&lt;u8&gt;</code> through
<code>serialize_bytes</code>.</p>
<p>Finally, <code>serialize_some</code> and <code>serialize_none</code> correspond to <code>Option::Some</code> and
<code>Option::None</code>. Users tend to have different expectations around the <code>Option</code>
enum compared to other enums. Serde JSON will serialize <code>Option::None</code> as <code>null</code>
and <code>Option::Some</code> as just the contained value.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-deserialize"><a class="header" href="#implementing-deserialize">Implementing Deserialize</a></h1>
<p>The <a href="https://docs.serde.rs/serde/de/trait.Deserialize.html"><code>Deserialize</code></a> trait looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">use serde::Deserializer;
</span><span class="boring">
</span>pub trait Deserialize&lt;'de&gt;: Sized {
    fn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Self, D::Error&gt;
    where
        D: Deserializer&lt;'de&gt;;
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>This method's job is to map the type into the <a href="data-model.html">Serde data model</a> by providing
the <a href="https://docs.serde.rs/serde/trait.Deserializer.html"><code>Deserializer</code></a> with a <a href="https://docs.serde.rs/serde/de/trait.Visitor.html"><code>Visitor</code></a> that can be driven by the <code>Deserializer</code>
to construct an instance of your type.</p>
<p>In most cases Serde's <a href="derive.html">derive</a> is able to generate an appropriate implementation
of <code>Deserialize</code> for structs and enums defined in your crate. Should you need to
customize the deserialization behavior for a type in a way that derive does not
support, you can implement <code>Deserialize</code> yourself. Implementing <code>Deserialize</code>
for a type tends to be more complicated than implementing <code>Serialize</code>.</p>
<p>The <code>Deserializer</code> trait supports two entry point styles which enables different
kinds of deserialization.</p>
<ol>
<li>
<p>The <code>deserialize_any</code> method. Self-describing data formats like JSON are able
to look at the serialized data and tell what it represents. For example the
JSON deserializer may see an opening curly brace (<code>{</code>) and know that it is
seeing a map. If the data format supports <code>Deserializer::deserialize_any</code>, it
will drive the Visitor using whatever type it sees in the input. JSON uses
this approach when deserializing <code>serde_json::Value</code> which is an enum that
can represent any JSON document. Without knowing what is in a JSON document,
we can deserialize it to <code>serde_json::Value</code> by going through
<code>Deserializer::deserialize_any</code>.</p>
</li>
<li>
<p>The various other <code>deserialize_*</code> methods. Non-self-describing formats like
Bincode need to be told what is in the input in order to deserialize it. The
<code>deserialize_*</code> methods are hints to the deserializer for how to interpret
the next piece of input. Non-self-describing formats are not able to
deserialize something like <code>serde_json::Value</code> which relies on
<code>Deserializer::deserialize_any</code>.</p>
</li>
</ol>
<p>When implementing <code>Deserialize</code>, you should avoid relying on
<code>Deserializer::deserialize_any</code> unless you need to be told by the Deserializer
what type is in the input. Know that relying on <code>Deserializer::deserialize_any</code>
means your data type will be able to deserialize from self-describing formats
only, ruling out Bincode and many others.</p>
<h2 id="the-visitor-trait"><a class="header" href="#the-visitor-trait">The Visitor trait</a></h2>
<p>A <a href="https://docs.serde.rs/serde/de/trait.Visitor.html"><code>Visitor</code></a> is instantiated by a <code>Deserialize</code> impl and passed to a
<code>Deserializer</code>. The <code>Deserializer</code> then calls a method on the <code>Visitor</code> in order
to construct the desired type.</p>
<p>Here is a <code>Visitor</code> that is able to deserialize a primitive <code>i32</code> from a variety
of types.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use std::fmt;

use serde::de::{self, Visitor};

<span class="boring">#[allow(dead_code)]
</span>struct I32Visitor;

impl&lt;'de&gt; Visitor&lt;'de&gt; for I32Visitor {
    type Value = i32;

    fn expecting(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        formatter.write_str(&quot;an integer between -2^31 and 2^31&quot;)
    }

    fn visit_i8&lt;E&gt;(self, value: i8) -&gt; Result&lt;Self::Value, E&gt;
    where
        E: de::Error,
    {
        Ok(i32::from(value))
    }

    fn visit_i32&lt;E&gt;(self, value: i32) -&gt; Result&lt;Self::Value, E&gt;
    where
        E: de::Error,
    {
        Ok(value)
    }

    fn visit_i64&lt;E&gt;(self, value: i64) -&gt; Result&lt;Self::Value, E&gt;
    where
        E: de::Error,
    {
        use std::i32;
        if value &gt;= i64::from(i32::MIN) &amp;&amp; value &lt;= i64::from(i32::MAX) {
            Ok(value as i32)
        } else {
            Err(E::custom(format!(&quot;i32 out of range: {}&quot;, value)))
        }
    }

    // Similar for other methods:
    //   - visit_i16
    //   - visit_u8
    //   - visit_u16
    //   - visit_u32
    //   - visit_u64
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>The <code>Visitor</code> trait has lots more methods that are not implemented for
<code>I32Visitor</code>. Leaving them unimplemented means a <a href="https://docs.serde.rs/serde/de/trait.Error.html#method.invalid_type">type error</a> is returned if
they get called. For example <code>I32Visitor</code> does not implement
<code>Visitor::visit_map</code>, so trying to deserialize an i32 when the input contains a
map is a type error.</p>
<h2 id="driving-a-visitor"><a class="header" href="#driving-a-visitor">Driving a Visitor</a></h2>
<p>Deserialize a value by passing a <code>Visitor</code> to the given <code>Deserializer</code>. The
<code>Deserializer</code> will call one of the <code>Visitor</code> methods depending on the input
data, which is known as &quot;driving&quot; the <code>Visitor</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">use serde::de::{Deserialize, Deserializer, Visitor};
</span><span class="boring">
</span><span class="boring">#[allow(non_camel_case_types)]
</span><span class="boring">struct i32;
</span><span class="boring">struct I32Visitor;
</span><span class="boring">
</span><span class="boring">impl&lt;'de&gt; Visitor&lt;'de&gt; for I32Visitor {
</span><span class="boring">    type Value = i32;
</span><span class="boring">
</span><span class="boring">    fn expecting(&amp;self, _: &amp;mut fmt::Formatter) -&gt; fmt::Result {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'de&gt; Deserialize&lt;'de&gt; for i32 {
    fn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;i32, D::Error&gt;
    where
        D: Deserializer&lt;'de&gt;,
    {
        deserializer.deserialize_i32(I32Visitor)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Note that a <code>Deserializer</code> will not necessarily follow the type hint, so the
call to <code>deserialize_i32</code> does not necessarily mean the <code>Deserializer</code> will call
<code>I32Visitor::visit_i32</code>. For example JSON treats all signed integer types alike.
The JSON <code>Deserializer</code> will call <code>visit_i64</code> for any signed integer and
<code>visit_u64</code> for any unsigned integer, even if hinted a different type.</p>
<h2 id="other-examples"><a class="header" href="#other-examples">Other examples</a></h2>
<ul>
<li><a href="deserialize-map.html">Deserializing a map</a></li>
<li><a href="deserialize-struct.html">Deserializing a struct</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unit-testing"><a class="header" href="#unit-testing">Unit testing</a></h1>
<p>The <a href="https://docs.serde.rs/serde_test/"><code>serde_test</code></a> crate provides a
convenient concise way to write unit tests for implementations of <code>Serialize</code>
and <code>Deserialize</code>.</p>
<p>The <code>Serialize</code> impl for a value can be characterized by the sequence of
<a href="https://docs.serde.rs/serde/ser/trait.Serializer.html"><code>Serializer</code></a> calls that
are made in the course of serializing the value, so <code>serde_test</code> provides a
<a href="https://docs.serde.rs/serde_test/enum.Token.html"><code>Token</code></a> abstraction which
corresponds roughly to <code>Serializer</code> method calls. It provides an
<code>assert_ser_tokens</code> function to test that a value serializes into a particular
sequence of method calls, an <code>assert_de_tokens</code> function to test that a value
can be deserialized from a particular sequence of method calls, and an
<code>assert_tokens</code> function to test both directions. It also provides functions to
test expected failure conditions.</p>
<p>Here is an example from the
<a href="https://github.com/contain-rs/linked-hash-map"><code>linked-hash-map</code></a> crate.</p>
<pre><code class="language-rust noplayground"><span class="boring">#[allow(unused_imports)]
</span>use linked_hash_map::LinkedHashMap;
<span class="boring">
</span><span class="boring">mod test {
</span><span class="boring">    use std::fmt;
</span><span class="boring">    use std::marker::PhantomData;
</span><span class="boring">
</span><span class="boring">    use serde::ser::{Serialize, Serializer, SerializeMap};
</span><span class="boring">    use serde::de::{Deserialize, Deserializer, Visitor, MapAccess};
</span><span class="boring">
</span>use serde_test::{Token, assert_tokens};
<span class="boring">
</span><span class="boring">    // The version of linked-hash-map used by yaml-rust is not compatible
</span><span class="boring">    // with Serde 0.9, and Skeptic tests cannot have more than one version
</span><span class="boring">    // of any dependency. Reimplement a dumb immitation here.
</span><span class="boring">    #[derive(PartialEq, Debug)]
</span><span class="boring">    struct LinkedHashMap&lt;K, V&gt;(Vec&lt;(K, V)&gt;);
</span><span class="boring">
</span><span class="boring">    impl&lt;K, V&gt; LinkedHashMap&lt;K, V&gt; {
</span><span class="boring">        fn new() -&gt; Self {
</span><span class="boring">            LinkedHashMap(Vec::new())
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn insert(&amp;mut self, k: K, v: V) {
</span><span class="boring">            self.0.push((k, v));
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl&lt;K, V&gt; Serialize for LinkedHashMap&lt;K, V&gt;
</span><span class="boring">    where
</span><span class="boring">        K: Serialize,
</span><span class="boring">        V: Serialize,
</span><span class="boring">    {
</span><span class="boring">        fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;
</span><span class="boring">        where
</span><span class="boring">            S: Serializer,
</span><span class="boring">        {
</span><span class="boring">            let mut map = serializer.serialize_map(Some(self.0.len()))?;
</span><span class="boring">            for &amp;(ref k, ref v) in &amp;self.0 {
</span><span class="boring">                map.serialize_entry(k, v)?;
</span><span class="boring">            }
</span><span class="boring">            map.end()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    struct LinkedHashMapVisitor&lt;K, V&gt;(PhantomData&lt;fn() -&gt; LinkedHashMap&lt;K, V&gt;&gt;);
</span><span class="boring">
</span><span class="boring">    impl&lt;'de, K, V&gt; Visitor&lt;'de&gt; for LinkedHashMapVisitor&lt;K, V&gt;
</span><span class="boring">    where
</span><span class="boring">        K: Deserialize&lt;'de&gt;,
</span><span class="boring">        V: Deserialize&lt;'de&gt;,
</span><span class="boring">    {
</span><span class="boring">        type Value = LinkedHashMap&lt;K, V&gt;;
</span><span class="boring">
</span><span class="boring">        fn expecting(&amp;self, _: &amp;mut fmt::Formatter) -&gt; fmt::Result {
</span><span class="boring">            unimplemented!()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn visit_map&lt;M&gt;(self, mut access: M) -&gt; Result&lt;Self::Value, M::Error&gt;
</span><span class="boring">        where
</span><span class="boring">            M: MapAccess&lt;'de&gt;,
</span><span class="boring">        {
</span><span class="boring">            let mut map = LinkedHashMap::new();
</span><span class="boring">            while let Some((key, value)) = access.next_entry()? {
</span><span class="boring">                map.insert(key, value);
</span><span class="boring">            }
</span><span class="boring">            Ok(map)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl&lt;'de, K, V&gt; Deserialize&lt;'de&gt; for LinkedHashMap&lt;K, V&gt;
</span><span class="boring">    where
</span><span class="boring">        K: Deserialize&lt;'de&gt;,
</span><span class="boring">        V: Deserialize&lt;'de&gt;,
</span><span class="boring">    {
</span><span class="boring">        fn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Self, D::Error&gt;
</span><span class="boring">        where
</span><span class="boring">            D: Deserializer&lt;'de&gt;,
</span><span class="boring">        {
</span><span class="boring">            deserializer.deserialize_map(LinkedHashMapVisitor(PhantomData))
</span><span class="boring">        }
</span><span class="boring">    }
</span>
#[test]
<span class="boring">fn skeptic_test_ser_de_empty() {}
</span>fn test_ser_de_empty() {
    let map = LinkedHashMap::&lt;char, u32&gt;::new();

    assert_tokens(&amp;map, &amp;[
        Token::Map { len: Some(0) },
        Token::MapEnd,
    ]);
}

#[test]
<span class="boring">fn skeptic_test_ser_de() {}
</span>fn test_ser_de() {
    let mut map = LinkedHashMap::new();
    map.insert('b', 20);
    map.insert('a', 10);
    map.insert('c', 30);

    assert_tokens(&amp;map, &amp;[
        Token::Map { len: Some(3) },
        Token::Char('b'),
        Token::I32(20),

        Token::Char('a'),
        Token::I32(10),

        Token::Char('c'),
        Token::I32(30),
        Token::MapEnd,
    ]);
}
<span class="boring">
</span><span class="boring">    pub fn run_tests() {
</span><span class="boring">        test_ser_de_empty();
</span><span class="boring">        test_ser_de();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    test::run_tests();
</span><span class="boring">}
</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-a-data-format"><a class="header" href="#writing-a-data-format">Writing a data format</a></h1>
<p>The most important thing to understand before writing a data format is that
<strong>Serde is not a parsing library</strong>. Nothing in Serde is going to help you parse
whatever format you are implementing. The role of Serde is very specific:</p>
<ul>
<li><strong>Serialization</strong> — taking arbitrary data structures from the user and
rendering them in the format with maximum efficiency.</li>
<li><strong>Deserialization</strong> — interpreting the data that you parse into data
structures of the user's choice with maximum efficiency.</li>
</ul>
<p>Parsing is neither of these things and you will either be writing parsing code
from scratch or using a parsing library to implement your Deserializer.</p>
<p>The second most important thing to understand is the <a href="data-model.html"><strong>Serde data model</strong></a>.</p>
<p>The following pages walk through a basic but functional JSON serializer and
deserializer implemented using Serde.</p>
<ul>
<li><a href="conventions.html">Conventions for what to export at the root of the crate</a></li>
<li><a href="error-handling.html">Serde error traits and error handling</a></li>
<li><a href="impl-serializer.html">Implementing a Serializer</a></li>
<li><a href="impl-deserializer.html">Implementing a Deserializer</a></li>
</ul>
<p>You can find these four source files all together as a buildable crate in <a href="https://github.com/serde-rs/example-format">this
GitHub repository</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conventions"><a class="header" href="#conventions">Conventions</a></h1>
<p>By convention a Serde data format crate provides the following in the root
module or re-exported from the root module:</p>
<ul>
<li>An Error type common to both serialization and deserialization.</li>
<li>A Result typedef which is equivalent to std::result::Result&lt;T, Error&gt;.</li>
<li>A Serializer type which implements serde::Serializer.</li>
<li>A Deserializer type which implements serde::Deserializer.</li>
<li>One or more to_abc functions depending on what types the format supports
serializing to. For example to_string which returns a String, to_bytes which
returns a Vec&lt;u8&gt;, or to_writer which writes into an <a href="https://doc.rust-lang.org/std/io/trait.Write.html"><code>io::Write</code></a>.</li>
<li>One or more from_xyz functions depending on what types the format supports
deserializing from. For example from_str which takes a &amp;str, from_bytes
which takes a &amp;[u8], or from_reader which takes an <a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>io::Read</code></a>.</li>
</ul>
<p>In addition, formats that provide serialization-specific or
deserialization-specific APIs beyond Serializer and Deserializer should expose
those under top-level <code>ser</code> and <code>de</code> modules. For example serde_json provides a
pluggable pretty-printer trait as <a href="https://docs.serde.rs/serde_json/ser/trait.Formatter.html"><code>serde_json::ser::Formatter</code></a>.</p>
<p>A basic data format begins like this. The three modules are discussed in more
detail on the following pages.</p>
<p><strong>src/lib.rs</strong></p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">macro_rules! modules {
</span><span class="boring">    (mod de) =&gt; {
</span><span class="boring">        mod de {
</span><span class="boring">            pub fn from_str() {}
</span><span class="boring">            pub type Deserializer = ();
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">    (mod error) =&gt; {
</span><span class="boring">        mod error {
</span><span class="boring">            pub type Error = ();
</span><span class="boring">            pub type Result = ();
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">    (mod ser) =&gt; {
</span><span class="boring">        mod ser {
</span><span class="boring">            pub fn to_string() {}
</span><span class="boring">            pub type Serializer = ();
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">    ($(mod $n:ident;)+) =&gt; {
</span><span class="boring">        $(
</span><span class="boring">            modules!(mod $n);
</span><span class="boring">        )+
</span><span class="boring">    };
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">modules! {
</span>mod de;
mod error;
mod ser;
<span class="boring">}
</span>
pub use de::{from_str, Deserializer};
pub use error::{Error, Result};
pub use ser::{to_string, Serializer};
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h1>
<p>During serialization, the <a href="https://docs.serde.rs/serde/trait.Serialize.html"><code>Serialize</code></a> trait maps a Rust data structure into
Serde's <a href="data-model.html">data model</a> and the <a href="https://docs.serde.rs/serde/ser/trait.Serializer.html"><code>Serializer</code></a> trait maps the data model into the
output format. During deserialization, the <a href="https://docs.serde.rs/serde/trait.Deserializer.html"><code>Deserializer</code></a> maps the input data
into Serde's data model and the <a href="https://docs.serde.rs/serde/trait.Deserialize.html"><code>Deserialize</code></a> and <a href="https://docs.serde.rs/serde/de/trait.Visitor.html"><code>Visitor</code></a> traits map the
data model into the resulting data structure. Any of these steps can fail.</p>
<ul>
<li><code>Serialize</code> can fail, for example when a <code>Mutex&lt;T&gt;</code> is being serialized and
the mutex happens to be poisoned.</li>
<li><code>Serializer</code> can fail, for example the Serde data model allows maps with
non-string keys but JSON does not.</li>
<li><code>Deserializer</code> can fail, especially if the input data is syntactically
invalid.</li>
<li><code>Deserialize</code> can fail, usually because the input is the wrong type for the
value it is being deserialized into.</li>
</ul>
<p>In Serde, errors from the <code>Serializer</code> and <code>Deserializer</code> work just like they
would in any other Rust library. The crate defines an error type, public
functions return a Result with that error type, and there are variants for the
various possible failure modes.</p>
<p>Handling of errors from the <code>Serialize</code> and <code>Deserialize</code>, the data structure
being processed by the library, is built around the <a href="https://docs.serde.rs/serde/ser/trait.Error.html"><code>ser::Error</code></a> and
<a href="https://docs.serde.rs/serde/de/trait.Error.html"><code>de::Error</code></a> traits. These traits allow the data format to expose constructors
for its error type for the data structure to use in various situations.</p>
<p><strong>src/error.rs</strong></p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">macro_rules! ignore {
</span><span class="boring">    ($($tt:tt)*) =&gt; {}
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">ignore! {
</span>use std;
<span class="boring">}
</span>use std::fmt::{self, Display};

use serde::{de, ser};

pub type Result&lt;T&gt; = std::result::Result&lt;T, Error&gt;;

// This is a bare-bones implementation. A real library would provide additional
// information in its error type, for example the line and column at which the
// error occurred, the byte offset into the input, or the current key being
// processed.
#[derive(Debug)]
pub enum Error {
    // One or more variants that can be created by data structures through the
    // `ser::Error` and `de::Error` traits. For example the Serialize impl for
    // Mutex&lt;T&gt; might return an error because the mutex is poisoned, or the
    // Deserialize impl for a struct may return an error because a required
    // field is missing.
    Message(String),

    // Zero or more variants that can be created directly by the Serializer and
    // Deserializer without going through `ser::Error` and `de::Error`. These
    // are specific to the format, in this case JSON.
    Eof,
    Syntax,
    ExpectedBoolean,
    ExpectedInteger,
    ExpectedString,
    ExpectedNull,
    ExpectedArray,
    ExpectedArrayComma,
    ExpectedArrayEnd,
    ExpectedMap,
    ExpectedMapColon,
    ExpectedMapComma,
    ExpectedMapEnd,
    ExpectedEnum,
    TrailingCharacters,
}

impl ser::Error for Error {
    fn custom&lt;T: Display&gt;(msg: T) -&gt; Self {
        Error::Message(msg.to_string())
    }
}

impl de::Error for Error {
    fn custom&lt;T: Display&gt;(msg: T) -&gt; Self {
        Error::Message(msg.to_string())
    }
}

impl Display for Error {
    fn fmt(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match self {
            Error::Message(msg) =&gt; formatter.write_str(msg),
            Error::Eof =&gt; formatter.write_str(&quot;unexpected end of input&quot;),
            /* and so forth */
<span class="boring">            _ =&gt; unimplemented!(),
</span>        }
    }
}

impl std::error::Error for Error {}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-a-serializer"><a class="header" href="#implementing-a-serializer">Implementing a Serializer</a></h1>
<p>This page gives a basic but functional implementation of a JSON serializer using
Serde.</p>
<p>The <a href="https://docs.serde.rs/serde/trait.Serializer.html"><code>Serializer</code></a> trait has a lot of methods but none of the ones in this
implementation are complicated. Each method corresponds to one of the types of
the <a href="data-model.html">Serde data model</a>. The serializer is responsible for mapping the data model
into the output representation, in this case JSON.</p>
<p>Refer to the rustdoc of the <code>Serializer</code> trait for examples of how each method
is used.</p>
<p><strong>src/ser.rs</strong></p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">mod error {
</span><span class="boring">    pub use serde::de::value::Error;
</span><span class="boring">    pub type Result&lt;T&gt; = ::std::result::Result&lt;T, Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>use serde::{ser, Serialize};

use error::{Error, Result};

pub struct Serializer {
    // This string starts empty and JSON is appended as values are serialized.
    output: String,
}

// By convention, the public API of a Serde serializer is one or more `to_abc`
// functions such as `to_string`, `to_bytes`, or `to_writer` depending on what
// Rust types the serializer is able to produce as output.
//
// This basic serializer supports only `to_string`.
pub fn to_string&lt;T&gt;(value: &amp;T) -&gt; Result&lt;String&gt;
where
    T: Serialize,
{
    let mut serializer = Serializer {
        output: String::new(),
    };
    value.serialize(&amp;mut serializer)?;
    Ok(serializer.output)
}

impl&lt;'a&gt; ser::Serializer for &amp;'a mut Serializer {
    // The output type produced by this `Serializer` during successful
    // serialization. Most serializers that produce text or binary output should
    // set `Ok = ()` and serialize into an `io::Write` or buffer contained
    // within the `Serializer` instance, as happens here. Serializers that build
    // in-memory data structures may be simplified by using `Ok` to propagate
    // the data structure around.
    type Ok = ();

    // The error type when some error occurs during serialization.
    type Error = Error;

    // Associated types for keeping track of additional state while serializing
    // compound data structures like sequences and maps. In this case no
    // additional state is required beyond what is already stored in the
    // Serializer struct.
    type SerializeSeq = Self;
    type SerializeTuple = Self;
    type SerializeTupleStruct = Self;
    type SerializeTupleVariant = Self;
    type SerializeMap = Self;
    type SerializeStruct = Self;
    type SerializeStructVariant = Self;

    // Here we go with the simple methods. The following 12 methods receive one
    // of the primitive types of the data model and map it to JSON by appending
    // into the output string.
    fn serialize_bool(self, v: bool) -&gt; Result&lt;()&gt; {
        self.output += if v { &quot;true&quot; } else { &quot;false&quot; };
        Ok(())
    }

    // JSON does not distinguish between different sizes of integers, so all
    // signed integers will be serialized the same and all unsigned integers
    // will be serialized the same. Other formats, especially compact binary
    // formats, may need independent logic for the different sizes.
    fn serialize_i8(self, v: i8) -&gt; Result&lt;()&gt; {
        self.serialize_i64(i64::from(v))
    }

    fn serialize_i16(self, v: i16) -&gt; Result&lt;()&gt; {
        self.serialize_i64(i64::from(v))
    }

    fn serialize_i32(self, v: i32) -&gt; Result&lt;()&gt; {
        self.serialize_i64(i64::from(v))
    }

    // Not particularly efficient but this is example code anyway. A more
    // performant approach would be to use the `itoa` crate.
    fn serialize_i64(self, v: i64) -&gt; Result&lt;()&gt; {
        self.output += &amp;v.to_string();
        Ok(())
    }

    fn serialize_u8(self, v: u8) -&gt; Result&lt;()&gt; {
        self.serialize_u64(u64::from(v))
    }

    fn serialize_u16(self, v: u16) -&gt; Result&lt;()&gt; {
        self.serialize_u64(u64::from(v))
    }

    fn serialize_u32(self, v: u32) -&gt; Result&lt;()&gt; {
        self.serialize_u64(u64::from(v))
    }

    fn serialize_u64(self, v: u64) -&gt; Result&lt;()&gt; {
        self.output += &amp;v.to_string();
        Ok(())
    }

    fn serialize_f32(self, v: f32) -&gt; Result&lt;()&gt; {
        self.serialize_f64(f64::from(v))
    }

    fn serialize_f64(self, v: f64) -&gt; Result&lt;()&gt; {
        self.output += &amp;v.to_string();
        Ok(())
    }

    // Serialize a char as a single-character string. Other formats may
    // represent this differently.
    fn serialize_char(self, v: char) -&gt; Result&lt;()&gt; {
        self.serialize_str(&amp;v.to_string())
    }

    // This only works for strings that don't require escape sequences but you
    // get the idea. For example it would emit invalid JSON if the input string
    // contains a '&quot;' character.
    fn serialize_str(self, v: &amp;str) -&gt; Result&lt;()&gt; {
        self.output += &quot;\&quot;&quot;;
        self.output += v;
        self.output += &quot;\&quot;&quot;;
        Ok(())
    }

    // Serialize a byte array as an array of bytes. Could also use a base64
    // string here. Binary formats will typically represent byte arrays more
    // compactly.
    fn serialize_bytes(self, v: &amp;[u8]) -&gt; Result&lt;()&gt; {
        use serde::ser::SerializeSeq;
        let mut seq = self.serialize_seq(Some(v.len()))?;
        for byte in v {
            seq.serialize_element(byte)?;
        }
        seq.end()
    }

    // An absent optional is represented as the JSON `null`.
    fn serialize_none(self) -&gt; Result&lt;()&gt; {
        self.serialize_unit()
    }

    // A present optional is represented as just the contained value. Note that
    // this is a lossy representation. For example the values `Some(())` and
    // `None` both serialize as just `null`. Unfortunately this is typically
    // what people expect when working with JSON. Other formats are encouraged
    // to behave more intelligently if possible.
    fn serialize_some&lt;T&gt;(self, value: &amp;T) -&gt; Result&lt;()&gt;
    where
        T: ?Sized + Serialize,
    {
        value.serialize(self)
    }

    // In Serde, unit means an anonymous value containing no data. Map this to
    // JSON as `null`.
    fn serialize_unit(self) -&gt; Result&lt;()&gt; {
        self.output += &quot;null&quot;;
        Ok(())
    }

    // Unit struct means a named value containing no data. Again, since there is
    // no data, map this to JSON as `null`. There is no need to serialize the
    // name in most formats.
    fn serialize_unit_struct(self, _name: &amp;'static str) -&gt; Result&lt;()&gt; {
        self.serialize_unit()
    }

    // When serializing a unit variant (or any other kind of variant), formats
    // can choose whether to keep track of it by index or by name. Binary
    // formats typically use the index of the variant and human-readable formats
    // typically use the name.
    fn serialize_unit_variant(
        self,
        _name: &amp;'static str,
        _variant_index: u32,
        variant: &amp;'static str,
    ) -&gt; Result&lt;()&gt; {
        self.serialize_str(variant)
    }

    // As is done here, serializers are encouraged to treat newtype structs as
    // insignificant wrappers around the data they contain.
    fn serialize_newtype_struct&lt;T&gt;(
        self,
        _name: &amp;'static str,
        value: &amp;T,
    ) -&gt; Result&lt;()&gt;
    where
        T: ?Sized + Serialize,
    {
        value.serialize(self)
    }

    // Note that newtype variant (and all of the other variant serialization
    // methods) refer exclusively to the &quot;externally tagged&quot; enum
    // representation.
    //
    // Serialize this to JSON in externally tagged form as `{ NAME: VALUE }`.
    fn serialize_newtype_variant&lt;T&gt;(
        self,
        _name: &amp;'static str,
        _variant_index: u32,
        variant: &amp;'static str,
        value: &amp;T,
    ) -&gt; Result&lt;()&gt;
    where
        T: ?Sized + Serialize,
    {
        self.output += &quot;{&quot;;
        variant.serialize(&amp;mut *self)?;
        self.output += &quot;:&quot;;
        value.serialize(&amp;mut *self)?;
        self.output += &quot;}&quot;;
        Ok(())
    }

    // Now we get to the serialization of compound types.
    //
    // The start of the sequence, each value, and the end are three separate
    // method calls. This one is responsible only for serializing the start,
    // which in JSON is `[`.
    //
    // The length of the sequence may or may not be known ahead of time. This
    // doesn't make a difference in JSON because the length is not represented
    // explicitly in the serialized form. Some serializers may only be able to
    // support sequences for which the length is known up front.
    fn serialize_seq(self, _len: Option&lt;usize&gt;) -&gt; Result&lt;Self::SerializeSeq&gt; {
        self.output += &quot;[&quot;;
        Ok(self)
    }

    // Tuples look just like sequences in JSON. Some formats may be able to
    // represent tuples more efficiently by omitting the length, since tuple
    // means that the corresponding `Deserialize implementation will know the
    // length without needing to look at the serialized data.
    fn serialize_tuple(self, len: usize) -&gt; Result&lt;Self::SerializeTuple&gt; {
        self.serialize_seq(Some(len))
    }

    // Tuple structs look just like sequences in JSON.
    fn serialize_tuple_struct(
        self,
        _name: &amp;'static str,
        len: usize,
    ) -&gt; Result&lt;Self::SerializeTupleStruct&gt; {
        self.serialize_seq(Some(len))
    }

    // Tuple variants are represented in JSON as `{ NAME: [DATA...] }`. Again
    // this method is only responsible for the externally tagged representation.
    fn serialize_tuple_variant(
        self,
        _name: &amp;'static str,
        _variant_index: u32,
        variant: &amp;'static str,
        _len: usize,
    ) -&gt; Result&lt;Self::SerializeTupleVariant&gt; {
        self.output += &quot;{&quot;;
        variant.serialize(&amp;mut *self)?;
        self.output += &quot;:[&quot;;
        Ok(self)
    }

    // Maps are represented in JSON as `{ K: V, K: V, ... }`.
    fn serialize_map(self, _len: Option&lt;usize&gt;) -&gt; Result&lt;Self::SerializeMap&gt; {
        self.output += &quot;{&quot;;
        Ok(self)
    }

    // Structs look just like maps in JSON. In particular, JSON requires that we
    // serialize the field names of the struct. Other formats may be able to
    // omit the field names when serializing structs because the corresponding
    // Deserialize implementation is required to know what the keys are without
    // looking at the serialized data.
    fn serialize_struct(
        self,
        _name: &amp;'static str,
        len: usize,
    ) -&gt; Result&lt;Self::SerializeStruct&gt; {
        self.serialize_map(Some(len))
    }

    // Struct variants are represented in JSON as `{ NAME: { K: V, ... } }`.
    // This is the externally tagged representation.
    fn serialize_struct_variant(
        self,
        _name: &amp;'static str,
        _variant_index: u32,
        variant: &amp;'static str,
        _len: usize,
    ) -&gt; Result&lt;Self::SerializeStructVariant&gt; {
        self.output += &quot;{&quot;;
        variant.serialize(&amp;mut *self)?;
        self.output += &quot;:{&quot;;
        Ok(self)
    }
}

// The following 7 impls deal with the serialization of compound types like
// sequences and maps. Serialization of such types is begun by a Serializer
// method and followed by zero or more calls to serialize individual elements of
// the compound type and one call to end the compound type.
//
// This impl is SerializeSeq so these methods are called after `serialize_seq`
// is called on the Serializer.
impl&lt;'a&gt; ser::SerializeSeq for &amp;'a mut Serializer {
    // Must match the `Ok` type of the serializer.
    type Ok = ();
    // Must match the `Error` type of the serializer.
    type Error = Error;

    // Serialize a single element of the sequence.
    fn serialize_element&lt;T&gt;(&amp;mut self, value: &amp;T) -&gt; Result&lt;()&gt;
    where
        T: ?Sized + Serialize,
    {
        if !self.output.ends_with('[') {
            self.output += &quot;,&quot;;
        }
        value.serialize(&amp;mut **self)
    }

    // Close the sequence.
    fn end(self) -&gt; Result&lt;()&gt; {
        self.output += &quot;]&quot;;
        Ok(())
    }
}

// Same thing but for tuples.
impl&lt;'a&gt; ser::SerializeTuple for &amp;'a mut Serializer {
    type Ok = ();
    type Error = Error;

    fn serialize_element&lt;T&gt;(&amp;mut self, value: &amp;T) -&gt; Result&lt;()&gt;
    where
        T: ?Sized + Serialize,
    {
        if !self.output.ends_with('[') {
            self.output += &quot;,&quot;;
        }
        value.serialize(&amp;mut **self)
    }

    fn end(self) -&gt; Result&lt;()&gt; {
        self.output += &quot;]&quot;;
        Ok(())
    }
}

// Same thing but for tuple structs.
impl&lt;'a&gt; ser::SerializeTupleStruct for &amp;'a mut Serializer {
    type Ok = ();
    type Error = Error;

    fn serialize_field&lt;T&gt;(&amp;mut self, value: &amp;T) -&gt; Result&lt;()&gt;
    where
        T: ?Sized + Serialize,
    {
        if !self.output.ends_with('[') {
            self.output += &quot;,&quot;;
        }
        value.serialize(&amp;mut **self)
    }

    fn end(self) -&gt; Result&lt;()&gt; {
        self.output += &quot;]&quot;;
        Ok(())
    }
}

// Tuple variants are a little different. Refer back to the
// `serialize_tuple_variant` method above:
//
//    self.output += &quot;{&quot;;
//    variant.serialize(&amp;mut *self)?;
//    self.output += &quot;:[&quot;;
//
// So the `end` method in this impl is responsible for closing both the `]` and
// the `}`.
impl&lt;'a&gt; ser::SerializeTupleVariant for &amp;'a mut Serializer {
    type Ok = ();
    type Error = Error;

    fn serialize_field&lt;T&gt;(&amp;mut self, value: &amp;T) -&gt; Result&lt;()&gt;
    where
        T: ?Sized + Serialize,
    {
        if !self.output.ends_with('[') {
            self.output += &quot;,&quot;;
        }
        value.serialize(&amp;mut **self)
    }

    fn end(self) -&gt; Result&lt;()&gt; {
        self.output += &quot;]}&quot;;
        Ok(())
    }
}

// Some `Serialize` types are not able to hold a key and value in memory at the
// same time so `SerializeMap` implementations are required to support
// `serialize_key` and `serialize_value` individually.
//
// There is a third optional method on the `SerializeMap` trait. The
// `serialize_entry` method allows serializers to optimize for the case where
// key and value are both available simultaneously. In JSON it doesn't make a
// difference so the default behavior for `serialize_entry` is fine.
impl&lt;'a&gt; ser::SerializeMap for &amp;'a mut Serializer {
    type Ok = ();
    type Error = Error;

    // The Serde data model allows map keys to be any serializable type. JSON
    // only allows string keys so the implementation below will produce invalid
    // JSON if the key serializes as something other than a string.
    //
    // A real JSON serializer would need to validate that map keys are strings.
    // This can be done by using a different Serializer to serialize the key
    // (instead of `&amp;mut **self`) and having that other serializer only
    // implement `serialize_str` and return an error on any other data type.
    fn serialize_key&lt;T&gt;(&amp;mut self, key: &amp;T) -&gt; Result&lt;()&gt;
    where
        T: ?Sized + Serialize,
    {
        if !self.output.ends_with('{') {
            self.output += &quot;,&quot;;
        }
        key.serialize(&amp;mut **self)
    }

    // It doesn't make a difference whether the colon is printed at the end of
    // `serialize_key` or at the beginning of `serialize_value`. In this case
    // the code is a bit simpler having it here.
    fn serialize_value&lt;T&gt;(&amp;mut self, value: &amp;T) -&gt; Result&lt;()&gt;
    where
        T: ?Sized + Serialize,
    {
        self.output += &quot;:&quot;;
        value.serialize(&amp;mut **self)
    }

    fn end(self) -&gt; Result&lt;()&gt; {
        self.output += &quot;}&quot;;
        Ok(())
    }
}

// Structs are like maps in which the keys are constrained to be compile-time
// constant strings.
impl&lt;'a&gt; ser::SerializeStruct for &amp;'a mut Serializer {
    type Ok = ();
    type Error = Error;

    fn serialize_field&lt;T&gt;(&amp;mut self, key: &amp;'static str, value: &amp;T) -&gt; Result&lt;()&gt;
    where
        T: ?Sized + Serialize,
    {
        if !self.output.ends_with('{') {
            self.output += &quot;,&quot;;
        }
        key.serialize(&amp;mut **self)?;
        self.output += &quot;:&quot;;
        value.serialize(&amp;mut **self)
    }

    fn end(self) -&gt; Result&lt;()&gt; {
        self.output += &quot;}&quot;;
        Ok(())
    }
}

// Similar to `SerializeTupleVariant`, here the `end` method is responsible for
// closing both of the curly braces opened by `serialize_struct_variant`.
impl&lt;'a&gt; ser::SerializeStructVariant for &amp;'a mut Serializer {
    type Ok = ();
    type Error = Error;

    fn serialize_field&lt;T&gt;(&amp;mut self, key: &amp;'static str, value: &amp;T) -&gt; Result&lt;()&gt;
    where
        T: ?Sized + Serialize,
    {
        if !self.output.ends_with('{') {
            self.output += &quot;,&quot;;
        }
        key.serialize(&amp;mut **self)?;
        self.output += &quot;:&quot;;
        value.serialize(&amp;mut **self)
    }

    fn end(self) -&gt; Result&lt;()&gt; {
        self.output += &quot;}}&quot;;
        Ok(())
    }
}

////////////////////////////////////////////////////////////////////////////////

<span class="boring">macro_rules! not_actually_test {
</span><span class="boring">    ($(#[test] $test:item)+) =&gt; {
</span><span class="boring">        $($test)+
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">not_actually_test! {
</span>#[test]
fn test_struct() {
    #[derive(Serialize)]
    struct Test {
        int: u32,
        seq: Vec&lt;&amp;'static str&gt;,
    }

    let test = Test {
        int: 1,
        seq: vec![&quot;a&quot;, &quot;b&quot;],
    };
    let expected = r#&quot;{&quot;int&quot;:1,&quot;seq&quot;:[&quot;a&quot;,&quot;b&quot;]}&quot;#;
    assert_eq!(to_string(&amp;test).unwrap(), expected);
}

#[test]
fn test_enum() {
    #[derive(Serialize)]
    enum E {
        Unit,
        Newtype(u32),
        Tuple(u32, u32),
        Struct { a: u32 },
    }

    let u = E::Unit;
    let expected = r#&quot;&quot;Unit&quot;&quot;#;
    assert_eq!(to_string(&amp;u).unwrap(), expected);

    let n = E::Newtype(1);
    let expected = r#&quot;{&quot;Newtype&quot;:1}&quot;#;
    assert_eq!(to_string(&amp;n).unwrap(), expected);

    let t = E::Tuple(1, 2);
    let expected = r#&quot;{&quot;Tuple&quot;:[1,2]}&quot;#;
    assert_eq!(to_string(&amp;t).unwrap(), expected);

    let s = E::Struct { a: 1 };
    let expected = r#&quot;{&quot;Struct&quot;:{&quot;a&quot;:1}}&quot;#;
    assert_eq!(to_string(&amp;s).unwrap(), expected);
}
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    test_struct();
</span><span class="boring">    test_enum();
</span><span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-a-deserializer"><a class="header" href="#implementing-a-deserializer">Implementing a Deserializer</a></h1>
<p>This page gives a basic but functional implementation of a JSON deserializer
using Serde.</p>
<p>As with the serializer, the <a href="https://docs.serde.rs/serde/de/trait.Deserializer.html"><code>Deserializer</code></a> trait has a lot of methods but none
of them are complicated in this implementation. The deserializer is responsible
for mapping the input data into <a href="data-model.html">Serde's data model</a> by invoking exactly one of
the methods on the <a href="https://docs.serde.rs/serde/de/trait.Visitor.html"><code>Visitor</code></a> that it receives.</p>
<p>The <code>Deserializer</code> methods are called by a <code>Deserialize</code> impl as a hint to
indicate what Serde data model type the <code>Deserialize</code> type expects to see in the
input. For self-describing formats like JSON, it is fine for the <code>Deserializer</code>
to ignore this hint and just call whichever <code>Visitor</code> method corresponds to the
content of the input data. Other formats, especially compact binary formats like
Bincode, rely on the hint to determine how the input data is to be interpreted.</p>
<p>Self-describing formats can save a lot of code by using the
<a href="https://docs.serde.rs/serde/macro.forward_to_deserialize_any.html"><code>forward_to_deserialize_any!</code></a> macro to ignore hints and forward some or all of
the methods of the <code>Deserializer</code> trait to the <code>deserialize_any</code> method.</p>
<p>The code below implements every method explicitly for documentation purposes but
there is no advantage to that.</p>
<p><a href="lifetimes.html">Deserializer lifetimes</a> have their own dedicated page.</p>
<p><strong>src/de.rs</strong></p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">mod error {
</span><span class="boring">    use std;
</span><span class="boring">    use std::fmt::{self, Display};
</span><span class="boring">
</span><span class="boring">    use serde::{ser, de};
</span><span class="boring">
</span><span class="boring">    pub type Result&lt;T&gt; = ::std::result::Result&lt;T, Error&gt;;
</span><span class="boring">
</span><span class="boring">    #[derive(Clone, Debug, PartialEq)]
</span><span class="boring">    pub enum Error {
</span><span class="boring">        Message(String),
</span><span class="boring">        Eof,
</span><span class="boring">        Syntax,
</span><span class="boring">        ExpectedBoolean,
</span><span class="boring">        ExpectedInteger,
</span><span class="boring">        ExpectedString,
</span><span class="boring">        ExpectedNull,
</span><span class="boring">        ExpectedArray,
</span><span class="boring">        ExpectedArrayComma,
</span><span class="boring">        ExpectedArrayEnd,
</span><span class="boring">        ExpectedMap,
</span><span class="boring">        ExpectedMapColon,
</span><span class="boring">        ExpectedMapComma,
</span><span class="boring">        ExpectedMapEnd,
</span><span class="boring">        ExpectedEnum,
</span><span class="boring">        TrailingCharacters,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl ser::Error for Error {
</span><span class="boring">        fn custom&lt;T: Display&gt;(msg: T) -&gt; Self {
</span><span class="boring">            Error::Message(msg.to_string())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl de::Error for Error {
</span><span class="boring">        fn custom&lt;T: Display&gt;(msg: T) -&gt; Self {
</span><span class="boring">            Error::Message(msg.to_string())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl Display for Error {
</span><span class="boring">        fn fmt(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {
</span><span class="boring">            match self {
</span><span class="boring">                Error::Message(msg) =&gt; formatter.write_str(msg),
</span><span class="boring">                Error::Eof =&gt; formatter.write_str(&quot;unexpected end of input&quot;),
</span><span class="boring">                /* and so forth */
</span><span class="boring">                _ =&gt; unimplemented!(),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl std::error::Error for Error {}
</span><span class="boring">}
</span><span class="boring">
</span>use std::ops::{AddAssign, MulAssign, Neg};

use serde::Deserialize;
use serde::de::{
    self, DeserializeSeed, EnumAccess, IntoDeserializer, MapAccess, SeqAccess,
    VariantAccess, Visitor,
};

use error::{Error, Result};

pub struct Deserializer&lt;'de&gt; {
    // This string starts with the input data and characters are truncated off
    // the beginning as data is parsed.
    input: &amp;'de str,
}

impl&lt;'de&gt; Deserializer&lt;'de&gt; {
    // By convention, `Deserializer` constructors are named like `from_xyz`.
    // That way basic use cases are satisfied by something like
    // `serde_json::from_str(...)` while advanced use cases that require a
    // deserializer can make one with `serde_json::Deserializer::from_str(...)`.
    pub fn from_str(input: &amp;'de str) -&gt; Self {
        Deserializer { input }
    }
}

// By convention, the public API of a Serde deserializer is one or more
// `from_xyz` methods such as `from_str`, `from_bytes`, or `from_reader`
// depending on what Rust types the deserializer is able to consume as input.
//
// This basic deserializer supports only `from_str`.
pub fn from_str&lt;'a, T&gt;(s: &amp;'a str) -&gt; Result&lt;T&gt;
where
    T: Deserialize&lt;'a&gt;,
{
    let mut deserializer = Deserializer::from_str(s);
    let t = T::deserialize(&amp;mut deserializer)?;
    if deserializer.input.is_empty() {
        Ok(t)
    } else {
        Err(Error::TrailingCharacters)
    }
}

// SERDE IS NOT A PARSING LIBRARY. This impl block defines a few basic parsing
// functions from scratch. More complicated formats may wish to use a dedicated
// parsing library to help implement their Serde deserializer.
impl&lt;'de&gt; Deserializer&lt;'de&gt; {
    // Look at the first character in the input without consuming it.
    fn peek_char(&amp;mut self) -&gt; Result&lt;char&gt; {
        self.input.chars().next().ok_or(Error::Eof)
    }

    // Consume the first character in the input.
    fn next_char(&amp;mut self) -&gt; Result&lt;char&gt; {
        let ch = self.peek_char()?;
        self.input = &amp;self.input[ch.len_utf8()..];
        Ok(ch)
    }

    // Parse the JSON identifier `true` or `false`.
    fn parse_bool(&amp;mut self) -&gt; Result&lt;bool&gt; {
        if self.input.starts_with(&quot;true&quot;) {
            self.input = &amp;self.input[&quot;true&quot;.len()..];
            Ok(true)
        } else if self.input.starts_with(&quot;false&quot;) {
            self.input = &amp;self.input[&quot;false&quot;.len()..];
            Ok(false)
        } else {
            Err(Error::ExpectedBoolean)
        }
    }

    // Parse a group of decimal digits as an unsigned integer of type T.
    //
    // This implementation is a bit too lenient, for example `001` is not
    // allowed in JSON. Also the various arithmetic operations can overflow and
    // panic or return bogus data. But it is good enough for example code!
    fn parse_unsigned&lt;T&gt;(&amp;mut self) -&gt; Result&lt;T&gt;
    where
        T: AddAssign&lt;T&gt; + MulAssign&lt;T&gt; + From&lt;u8&gt;,
    {
        let mut int = match self.next_char()? {
            ch @ '0'..='9' =&gt; T::from(ch as u8 - b'0'),
            _ =&gt; {
                return Err(Error::ExpectedInteger);
            }
        };
        loop {
            match self.input.chars().next() {
                Some(ch @ '0'..='9') =&gt; {
                    self.input = &amp;self.input[1..];
                    int *= T::from(10);
                    int += T::from(ch as u8 - b'0');
                }
                _ =&gt; {
                    return Ok(int);
                }
            }
        }
    }

    // Parse a possible minus sign followed by a group of decimal digits as a
    // signed integer of type T.
    fn parse_signed&lt;T&gt;(&amp;mut self) -&gt; Result&lt;T&gt;
    where
        T: Neg&lt;Output = T&gt; + AddAssign&lt;T&gt; + MulAssign&lt;T&gt; + From&lt;i8&gt;,
    {
        // Optional minus sign, delegate to `parse_unsigned`, negate if negative.
        unimplemented!()
    }

    // Parse a string until the next '&quot;' character.
    //
    // Makes no attempt to handle escape sequences. What did you expect? This is
    // example code!
    fn parse_string(&amp;mut self) -&gt; Result&lt;&amp;'de str&gt; {
        if self.next_char()? != '&quot;' {
            return Err(Error::ExpectedString);
        }
        match self.input.find('&quot;') {
            Some(len) =&gt; {
                let s = &amp;self.input[..len];
                self.input = &amp;self.input[len + 1..];
                Ok(s)
            }
            None =&gt; Err(Error::Eof),
        }
    }
}

impl&lt;'de, 'a&gt; de::Deserializer&lt;'de&gt; for &amp;'a mut Deserializer&lt;'de&gt; {
    type Error = Error;

    // Look at the input data to decide what Serde data model type to
    // deserialize as. Not all data formats are able to support this operation.
    // Formats that support `deserialize_any` are known as self-describing.
    fn deserialize_any&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        match self.peek_char()? {
            'n' =&gt; self.deserialize_unit(visitor),
            't' | 'f' =&gt; self.deserialize_bool(visitor),
            '&quot;' =&gt; self.deserialize_str(visitor),
            '0'..='9' =&gt; self.deserialize_u64(visitor),
            '-' =&gt; self.deserialize_i64(visitor),
            '[' =&gt; self.deserialize_seq(visitor),
            '{' =&gt; self.deserialize_map(visitor),
            _ =&gt; Err(Error::Syntax),
        }
    }

    // Uses the `parse_bool` parsing function defined above to read the JSON
    // identifier `true` or `false` from the input.
    //
    // Parsing refers to looking at the input and deciding that it contains the
    // JSON value `true` or `false`.
    //
    // Deserialization refers to mapping that JSON value into Serde's data
    // model by invoking one of the `Visitor` methods. In the case of JSON and
    // bool that mapping is straightforward so the distinction may seem silly,
    // but in other cases Deserializers sometimes perform non-obvious mappings.
    // For example the TOML format has a Datetime type and Serde's data model
    // does not. In the `toml` crate, a Datetime in the input is deserialized by
    // mapping it to a Serde data model &quot;struct&quot; type with a special name and a
    // single field containing the Datetime represented as a string.
    fn deserialize_bool&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        visitor.visit_bool(self.parse_bool()?)
    }

    // The `parse_signed` function is generic over the integer type `T` so here
    // it is invoked with `T=i8`. The next 8 methods are similar.
    fn deserialize_i8&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        visitor.visit_i8(self.parse_signed()?)
    }

    fn deserialize_i16&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        visitor.visit_i16(self.parse_signed()?)
    }

    fn deserialize_i32&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        visitor.visit_i32(self.parse_signed()?)
    }

    fn deserialize_i64&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        visitor.visit_i64(self.parse_signed()?)
    }

    fn deserialize_u8&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        visitor.visit_u8(self.parse_unsigned()?)
    }

    fn deserialize_u16&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        visitor.visit_u16(self.parse_unsigned()?)
    }

    fn deserialize_u32&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        visitor.visit_u32(self.parse_unsigned()?)
    }

    fn deserialize_u64&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        visitor.visit_u64(self.parse_unsigned()?)
    }

    // Float parsing is stupidly hard.
    fn deserialize_f32&lt;V&gt;(self, _visitor: V) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        unimplemented!()
    }

    // Float parsing is stupidly hard.
    fn deserialize_f64&lt;V&gt;(self, _visitor: V) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        unimplemented!()
    }

    // The `Serializer` implementation on the previous page serialized chars as
    // single-character strings so handle that representation here.
    fn deserialize_char&lt;V&gt;(self, _visitor: V) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        // Parse a string, check that it is one character, call `visit_char`.
        unimplemented!()
    }

    // Refer to the &quot;Understanding deserializer lifetimes&quot; page for information
    // about the three deserialization flavors of strings in Serde.
    fn deserialize_str&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        visitor.visit_borrowed_str(self.parse_string()?)
    }

    fn deserialize_string&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        self.deserialize_str(visitor)
    }

    // The `Serializer` implementation on the previous page serialized byte
    // arrays as JSON arrays of bytes. Handle that representation here.
    fn deserialize_bytes&lt;V&gt;(self, _visitor: V) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        unimplemented!()
    }

    fn deserialize_byte_buf&lt;V&gt;(self, _visitor: V) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        unimplemented!()
    }

    // An absent optional is represented as the JSON `null` and a present
    // optional is represented as just the contained value.
    //
    // As commented in `Serializer` implementation, this is a lossy
    // representation. For example the values `Some(())` and `None` both
    // serialize as just `null`. Unfortunately this is typically what people
    // expect when working with JSON. Other formats are encouraged to behave
    // more intelligently if possible.
    fn deserialize_option&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        if self.input.starts_with(&quot;null&quot;) {
            self.input = &amp;self.input[&quot;null&quot;.len()..];
            visitor.visit_none()
        } else {
            visitor.visit_some(self)
        }
    }

    // In Serde, unit means an anonymous value containing no data.
    fn deserialize_unit&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        if self.input.starts_with(&quot;null&quot;) {
            self.input = &amp;self.input[&quot;null&quot;.len()..];
            visitor.visit_unit()
        } else {
            Err(Error::ExpectedNull)
        }
    }

    // Unit struct means a named value containing no data.
    fn deserialize_unit_struct&lt;V&gt;(
        self,
        _name: &amp;'static str,
        visitor: V,
    ) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        self.deserialize_unit(visitor)
    }

    // As is done here, serializers are encouraged to treat newtype structs as
    // insignificant wrappers around the data they contain. That means not
    // parsing anything other than the contained value.
    fn deserialize_newtype_struct&lt;V&gt;(
        self,
        _name: &amp;'static str,
        visitor: V,
    ) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        visitor.visit_newtype_struct(self)
    }

    // Deserialization of compound types like sequences and maps happens by
    // passing the visitor an &quot;Access&quot; object that gives it the ability to
    // iterate through the data contained in the sequence.
    fn deserialize_seq&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        // Parse the opening bracket of the sequence.
        if self.next_char()? == '[' {
            // Give the visitor access to each element of the sequence.
            let value = visitor.visit_seq(CommaSeparated::new(self))?;
            // Parse the closing bracket of the sequence.
            if self.next_char()? == ']' {
                Ok(value)
            } else {
                Err(Error::ExpectedArrayEnd)
            }
        } else {
            Err(Error::ExpectedArray)
        }
    }

    // Tuples look just like sequences in JSON. Some formats may be able to
    // represent tuples more efficiently.
    //
    // As indicated by the length parameter, the `Deserialize` implementation
    // for a tuple in the Serde data model is required to know the length of the
    // tuple before even looking at the input data.
    fn deserialize_tuple&lt;V&gt;(self, _len: usize, visitor: V) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        self.deserialize_seq(visitor)
    }

    // Tuple structs look just like sequences in JSON.
    fn deserialize_tuple_struct&lt;V&gt;(
        self,
        _name: &amp;'static str,
        _len: usize,
        visitor: V,
    ) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        self.deserialize_seq(visitor)
    }

    // Much like `deserialize_seq` but calls the visitors `visit_map` method
    // with a `MapAccess` implementation, rather than the visitor's `visit_seq`
    // method with a `SeqAccess` implementation.
    fn deserialize_map&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        // Parse the opening brace of the map.
        if self.next_char()? == '{' {
            // Give the visitor access to each entry of the map.
            let value = visitor.visit_map(CommaSeparated::new(self))?;
            // Parse the closing brace of the map.
            if self.next_char()? == '}' {
                Ok(value)
            } else {
                Err(Error::ExpectedMapEnd)
            }
        } else {
            Err(Error::ExpectedMap)
        }
    }

    // Structs look just like maps in JSON.
    //
    // Notice the `fields` parameter - a &quot;struct&quot; in the Serde data model means
    // that the `Deserialize` implementation is required to know what the fields
    // are before even looking at the input data. Any key-value pairing in which
    // the fields cannot be known ahead of time is probably a map.
    fn deserialize_struct&lt;V&gt;(
        self,
        _name: &amp;'static str,
        _fields: &amp;'static [&amp;'static str],
        visitor: V,
    ) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        self.deserialize_map(visitor)
    }

    fn deserialize_enum&lt;V&gt;(
        self,
        _name: &amp;'static str,
        _variants: &amp;'static [&amp;'static str],
        visitor: V,
    ) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        if self.peek_char()? == '&quot;' {
            // Visit a unit variant.
            visitor.visit_enum(self.parse_string()?.into_deserializer())
        } else if self.next_char()? == '{' {
            // Visit a newtype variant, tuple variant, or struct variant.
            let value = visitor.visit_enum(Enum::new(self))?;
            // Parse the matching close brace.
            if self.next_char()? == '}' {
                Ok(value)
            } else {
                Err(Error::ExpectedMapEnd)
            }
        } else {
            Err(Error::ExpectedEnum)
        }
    }

    // An identifier in Serde is the type that identifies a field of a struct or
    // the variant of an enum. In JSON, struct fields and enum variants are
    // represented as strings. In other formats they may be represented as
    // numeric indices.
    fn deserialize_identifier&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        self.deserialize_str(visitor)
    }

    // Like `deserialize_any` but indicates to the `Deserializer` that it makes
    // no difference which `Visitor` method is called because the data is
    // ignored.
    //
    // Some deserializers are able to implement this more efficiently than
    // `deserialize_any`, for example by rapidly skipping over matched
    // delimiters without paying close attention to the data in between.
    //
    // Some formats are not able to implement this at all. Formats that can
    // implement `deserialize_any` and `deserialize_ignored_any` are known as
    // self-describing.
    fn deserialize_ignored_any&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        self.deserialize_any(visitor)
    }
}

// In order to handle commas correctly when deserializing a JSON array or map,
// we need to track whether we are on the first element or past the first
// element.
struct CommaSeparated&lt;'a, 'de: 'a&gt; {
    de: &amp;'a mut Deserializer&lt;'de&gt;,
    first: bool,
}

impl&lt;'a, 'de&gt; CommaSeparated&lt;'a, 'de&gt; {
    fn new(de: &amp;'a mut Deserializer&lt;'de&gt;) -&gt; Self {
        CommaSeparated {
            de,
            first: true,
        }
    }
}

// `SeqAccess` is provided to the `Visitor` to give it the ability to iterate
// through elements of the sequence.
impl&lt;'de, 'a&gt; SeqAccess&lt;'de&gt; for CommaSeparated&lt;'a, 'de&gt; {
    type Error = Error;

    fn next_element_seed&lt;T&gt;(&amp;mut self, seed: T) -&gt; Result&lt;Option&lt;T::Value&gt;&gt;
    where
        T: DeserializeSeed&lt;'de&gt;,
    {
        // Check if there are no more elements.
        if self.de.peek_char()? == ']' {
            return Ok(None);
        }
        // Comma is required before every element except the first.
        if !self.first &amp;&amp; self.de.next_char()? != ',' {
            return Err(Error::ExpectedArrayComma);
        }
        self.first = false;
        // Deserialize an array element.
        seed.deserialize(&amp;mut *self.de).map(Some)
    }
}

// `MapAccess` is provided to the `Visitor` to give it the ability to iterate
// through entries of the map.
impl&lt;'de, 'a&gt; MapAccess&lt;'de&gt; for CommaSeparated&lt;'a, 'de&gt; {
    type Error = Error;

    fn next_key_seed&lt;K&gt;(&amp;mut self, seed: K) -&gt; Result&lt;Option&lt;K::Value&gt;&gt;
    where
        K: DeserializeSeed&lt;'de&gt;,
    {
        // Check if there are no more entries.
        if self.de.peek_char()? == '}' {
            return Ok(None);
        }
        // Comma is required before every entry except the first.
        if !self.first &amp;&amp; self.de.next_char()? != ',' {
            return Err(Error::ExpectedMapComma);
        }
        self.first = false;
        // Deserialize a map key.
        seed.deserialize(&amp;mut *self.de).map(Some)
    }

    fn next_value_seed&lt;V&gt;(&amp;mut self, seed: V) -&gt; Result&lt;V::Value&gt;
    where
        V: DeserializeSeed&lt;'de&gt;,
    {
        // It doesn't make a difference whether the colon is parsed at the end
        // of `next_key_seed` or at the beginning of `next_value_seed`. In this
        // case the code is a bit simpler having it here.
        if self.de.next_char()? != ':' {
            return Err(Error::ExpectedMapColon);
        }
        // Deserialize a map value.
        seed.deserialize(&amp;mut *self.de)
    }
}

struct Enum&lt;'a, 'de: 'a&gt; {
    de: &amp;'a mut Deserializer&lt;'de&gt;,
}

impl&lt;'a, 'de&gt; Enum&lt;'a, 'de&gt; {
    fn new(de: &amp;'a mut Deserializer&lt;'de&gt;) -&gt; Self {
        Enum { de }
    }
}

// `EnumAccess` is provided to the `Visitor` to give it the ability to determine
// which variant of the enum is supposed to be deserialized.
//
// Note that all enum deserialization methods in Serde refer exclusively to the
// &quot;externally tagged&quot; enum representation.
impl&lt;'de, 'a&gt; EnumAccess&lt;'de&gt; for Enum&lt;'a, 'de&gt; {
    type Error = Error;
    type Variant = Self;

    fn variant_seed&lt;V&gt;(self, seed: V) -&gt; Result&lt;(V::Value, Self::Variant)&gt;
    where
        V: DeserializeSeed&lt;'de&gt;,
    {
        // The `deserialize_enum` method parsed a `{` character so we are
        // currently inside of a map. The seed will be deserializing itself from
        // the key of the map.
        let val = seed.deserialize(&amp;mut *self.de)?;
        // Parse the colon separating map key from value.
        if self.de.next_char()? == ':' {
            Ok((val, self))
        } else {
            Err(Error::ExpectedMapColon)
        }
    }
}

// `VariantAccess` is provided to the `Visitor` to give it the ability to see
// the content of the single variant that it decided to deserialize.
impl&lt;'de, 'a&gt; VariantAccess&lt;'de&gt; for Enum&lt;'a, 'de&gt; {
    type Error = Error;

    // If the `Visitor` expected this variant to be a unit variant, the input
    // should have been the plain string case handled in `deserialize_enum`.
    fn unit_variant(self) -&gt; Result&lt;()&gt; {
        Err(Error::ExpectedString)
    }

    // Newtype variants are represented in JSON as `{ NAME: VALUE }` so
    // deserialize the value here.
    fn newtype_variant_seed&lt;T&gt;(self, seed: T) -&gt; Result&lt;T::Value&gt;
    where
        T: DeserializeSeed&lt;'de&gt;,
    {
        seed.deserialize(self.de)
    }

    // Tuple variants are represented in JSON as `{ NAME: [DATA...] }` so
    // deserialize the sequence of data here.
    fn tuple_variant&lt;V&gt;(self, _len: usize, visitor: V) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        de::Deserializer::deserialize_seq(self.de, visitor)
    }

    // Struct variants are represented in JSON as `{ NAME: { K: V, ... } }` so
    // deserialize the inner map here.
    fn struct_variant&lt;V&gt;(
        self,
        _fields: &amp;'static [&amp;'static str],
        visitor: V,
    ) -&gt; Result&lt;V::Value&gt;
    where
        V: Visitor&lt;'de&gt;,
    {
        de::Deserializer::deserialize_map(self.de, visitor)
    }
}

////////////////////////////////////////////////////////////////////////////////

<span class="boring">macro_rules! not_actually_test {
</span><span class="boring">    ($(#[test] $test:item)+) =&gt; {
</span><span class="boring">        $($test)+
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">not_actually_test! {
</span>#[test]
fn test_struct() {
    #[derive(Deserialize, PartialEq, Debug)]
    struct Test {
        int: u32,
        seq: Vec&lt;String&gt;,
    }

    let j = r#&quot;{&quot;int&quot;:1,&quot;seq&quot;:[&quot;a&quot;,&quot;b&quot;]}&quot;#;
    let expected = Test {
        int: 1,
        seq: vec![&quot;a&quot;.to_owned(), &quot;b&quot;.to_owned()],
    };
    assert_eq!(expected, from_str(j).unwrap());
}

#[test]
fn test_enum() {
    #[derive(Deserialize, PartialEq, Debug)]
    enum E {
        Unit,
        Newtype(u32),
        Tuple(u32, u32),
        Struct { a: u32 },
    }

    let j = r#&quot;&quot;Unit&quot;&quot;#;
    let expected = E::Unit;
    assert_eq!(expected, from_str(j).unwrap());

    let j = r#&quot;{&quot;Newtype&quot;:1}&quot;#;
    let expected = E::Newtype(1);
    assert_eq!(expected, from_str(j).unwrap());

    let j = r#&quot;{&quot;Tuple&quot;:[1,2]}&quot;#;
    let expected = E::Tuple(1, 2);
    assert_eq!(expected, from_str(j).unwrap());

    let j = r#&quot;{&quot;Struct&quot;:{&quot;a&quot;:1}}&quot;#;
    let expected = E::Struct { a: 1 };
    assert_eq!(expected, from_str(j).unwrap());
}
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    test_struct();
</span><span class="boring">    test_enum();
</span><span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-deserializer-lifetimes"><a class="header" href="#understanding-deserializer-lifetimes">Understanding deserializer lifetimes</a></h1>
<p>The <a href="https://docs.serde.rs/serde/trait.Deserialize.html"><code>Deserialize</code></a> and <a href="https://docs.serde.rs/serde/trait.Deserializer.html"><code>Deserializer</code></a> traits both have a lifetime called
<code>'de</code>, as do some of the other deserialization-related traits.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">use serde::Deserializer;
</span><span class="boring">
</span>trait Deserialize&lt;'de&gt;: Sized {
    fn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Self, D::Error&gt;
    where
        D: Deserializer&lt;'de&gt;;
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>This lifetime is what enables Serde to safely perform efficient zero-copy
deserialization across a variety of data formats, something that would be
impossible or recklessly unsafe in languages other than Rust.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(dead_code)]
</span><span class="boring">
</span><span class="boring">use serde::Deserialize;
</span><span class="boring">
</span>#[derive(Deserialize)]
struct User&lt;'a&gt; {
    id: u32,
    name: &amp;'a str,
    screen_name: &amp;'a str,
    location: &amp;'a str,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Zero-copy deserialization means deserializing into a data structure, like the
<code>User</code> struct above, that borrows string or byte array data from the string or
byte array holding the input. This avoids allocating memory to store a string
for each individual field and then copying string data out of the input over to
the newly allocated field. Rust guarantees that the input data outlives the
period during which the output data structure is in scope, meaning it is
impossible to have dangling pointer errors as a result of losing the input data
while the output data structure still refers to it.</p>
<h2 id="trait-bounds"><a class="header" href="#trait-bounds">Trait bounds</a></h2>
<p>There are two main ways to write <code>Deserialize</code> trait bounds, whether on an impl
block or a function or anywhere else.</p>
<ul>
<li>
<p><strong><code>&lt;'de, T&gt; where T: Deserialize&lt;'de&gt;</code></strong></p>
<p>This means &quot;T can be deserialized from <strong>some</strong> lifetime.&quot; The caller gets
to decide what lifetime that is. Typically this is used when the caller also
provides the data that is being deserialized from, for example in a function
like <a href="https://docs.serde.rs/serde_json/fn.from_str.html"><code>serde_json::from_str</code></a>. In that case the input data must also have
lifetime <code>'de</code>, for example it could be <code>&amp;'de str</code>.</p>
</li>
<li>
<p><strong><code>&lt;T&gt; where T: DeserializeOwned</code></strong></p>
<p>This means &quot;T can be deserialized from <strong>any</strong> lifetime.&quot; The callee gets to
decide what lifetime. Usually this is because the data that is being
deserialized from is going to be thrown away before the function returns, so
T must not be allowed to borrow from it. For example a function that accepts
base64-encoded data as input, decodes it from base64, deserializes a value
of type T, then throws away the result of base64 decoding. Another common
use of this bound is functions that deserialize from an IO stream, such as
<a href="https://docs.serde.rs/serde_json/fn.from_reader.html"><code>serde_json::from_reader</code></a>.</p>
<p>To say it more technically, the <a href="https://docs.serde.rs/serde/de/trait.DeserializeOwned.html"><code>DeserializeOwned</code></a> trait is equivalent to
the <a href="https://doc.rust-lang.org/nomicon/hrtb.html">higher-rank trait bound</a> <code>for&lt;'de&gt; Deserialize&lt;'de&gt;</code>. The only
difference is <code>DeserializeOwned</code> is more intuitive to read. It means T owns
all the data that gets deserialized.</p>
</li>
</ul>
<p>Note that <code>&lt;T&gt; where T: Deserialize&lt;'static&gt;</code> is never what you want. Also
<code>Deserialize&lt;'de&gt; + 'static</code> is never what you want. Generally writing <code>'static</code>
anywhere near <code>Deserialize</code> is a sign of being on the wrong track. Use one of
the above bounds instead.</p>
<h2 id="transient-borrowed-and-owned-data"><a class="header" href="#transient-borrowed-and-owned-data">Transient, borrowed, and owned data</a></h2>
<p>The Serde data model has three flavors of strings and byte arrays during
deserialization. They correspond to different methods on the <a href="https://docs.serde.rs/serde/de/trait.Visitor.html"><code>Visitor</code></a> trait.</p>
<ul>
<li><strong>Transient</strong> — <a href="https://docs.serde.rs/serde/de/trait.Visitor.html#method.visit_str"><code>visit_str</code></a> accepts a <code>&amp;str</code>.</li>
<li><strong>Borrowed</strong> — <a href="https://docs.serde.rs/serde/de/trait.Visitor.html#method.visit_borrowed_str"><code>visit_borrowed_str</code></a> accepts a <code>&amp;'de str</code>.</li>
<li><strong>Owned</strong> — <a href="https://docs.serde.rs/serde/de/trait.Visitor.html#method.visit_string"><code>visit_string</code></a> accepts a <code>String</code>.</li>
</ul>
<p>Transient data is not guaranteed to last beyond the method call it is passed to.
Often this is sufficient, for example when deserializing something like an IP
address from a Serde string using the <a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a> trait. When it is not
sufficient, the data can be copied by calling <a href="https://doc.rust-lang.org/std/borrow/trait.ToOwned.html"><code>to_owned()</code></a>. Deserializers
commonly use transient data when input from an IO stream is being buffered in
memory before being passed to the <code>Visitor</code>, or when escape sequences are being
processed so the resulting string is not present verbatim in the input.</p>
<p>Borrowed data is guaranteed to live at least as long as the <code>'de</code> lifetime
parameter of the <code>Deserializer</code>. Not all deserializers support handing out
borrowed data. For example when deserializing from an IO stream no data can be
borrowed.</p>
<p>Owned data is guaranteed to live as long as the <a href="https://docs.serde.rs/serde/de/trait.Visitor.html"><code>Visitor</code></a> wants it to. Some
visitors benefit from receiving owned data. For example the <code>Deserialize</code> impl
for Rust's <code>String</code> type benefits from being given ownership of the Serde string
data that has been deserialized.</p>
<h2 id="the-deserializede-lifetime"><a class="header" href="#the-deserializede-lifetime">The Deserialize&lt;'de&gt; lifetime</a></h2>
<p>This lifetime records the constraints on how long data borrowed by this type
must be valid.</p>
<p>Every lifetime of data borrowed by this type must be a bound on the <code>'de</code>
lifetime of its <code>Deserialize</code> impl. If this type borrows data with lifetime
<code>'a</code>, then <code>'de</code> must be constrained to outlive <code>'a</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(dead_code)]
</span><span class="boring">
</span><span class="boring">trait Deserialize&lt;'de&gt; {}
</span><span class="boring">
</span>struct S&lt;'a, 'b, T&gt; {
    a: &amp;'a str,
    b: &amp;'b str,
    bb: &amp;'b str,
    t: T,
}

impl&lt;'de: 'a + 'b, 'a, 'b, T&gt; Deserialize&lt;'de&gt; for S&lt;'a, 'b, T&gt;
where
    T: Deserialize&lt;'de&gt;,
{
    /* ... */
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>If this type does not borrow any data from the <code>Deserializer</code>, there are simply
no bounds on the <code>'de</code> lifetime. Such types automatically implement the
<a href="https://docs.serde.rs/serde/de/trait.DeserializeOwned.html"><code>DeserializeOwned</code></a> trait.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(dead_code)]
</span><span class="boring">
</span><span class="boring">pub trait Deserialize&lt;'de&gt; {}
</span><span class="boring">
</span>struct S {
    owned: String,
}

impl&lt;'de&gt; Deserialize&lt;'de&gt; for S {
    /* ... */
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>The <code>'de</code> lifetime <strong>should not</strong> appear in the type to which the <code>Deserialize</code>
impl applies.</p>
<pre><code class="language-diff">- // Do not do this. Sooner or later you will be sad.
- impl&lt;'de&gt; Deserialize&lt;'de&gt; for Q&lt;'de&gt; {

+ // Do this instead.
+ impl&lt;'de: 'a, 'a&gt; Deserialize&lt;'de&gt; for Q&lt;'a&gt; {
</code></pre>
<h2 id="the-deserializerde-lifetime"><a class="header" href="#the-deserializerde-lifetime">The Deserializer&lt;'de&gt; lifetime</a></h2>
<p>This is the lifetime of data that can be borrowed from the <code>Deserializer</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(dead_code)]
</span><span class="boring">
</span><span class="boring">pub trait Deserializer&lt;'de&gt; {}
</span><span class="boring">
</span>struct MyDeserializer&lt;'de&gt; {
    input_data: &amp;'de [u8],
    pos: usize,
}

impl&lt;'de&gt; Deserializer&lt;'de&gt; for MyDeserializer&lt;'de&gt; {
    /* ... */
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>If the <code>Deserializer</code> never invokes <a href="https://docs.serde.rs/serde/de/trait.Visitor.html#method.visit_borrowed_str"><code>visit_borrowed_str</code></a> or
<a href="https://docs.serde.rs/serde/de/trait.Visitor.html#method.visit_borrowed_bytes"><code>visit_borrowed_bytes</code></a>, the <code>'de</code> lifetime will be an unconstrained lifetime
parameter.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(dead_code)]
</span><span class="boring">
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">pub trait Deserializer&lt;'de&gt; {}
</span><span class="boring">
</span>struct MyDeserializer&lt;R&gt; {
    read: R,
}

impl&lt;'de, R&gt; Deserializer&lt;'de&gt; for MyDeserializer&lt;R&gt;
where
    R: io::Read,
{
    /* ... */
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="borrowing-data-in-a-derived-impl"><a class="header" href="#borrowing-data-in-a-derived-impl">Borrowing data in a derived impl</a></h2>
<p>Fields of type <code>&amp;str</code> and <code>&amp;[u8]</code> are implicitly borrowed from the input data by
Serde. Any other type of field can opt in to borrowing by using the
<code>#[serde(borrow)]</code> attribute.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(dead_code)]
</span><span class="boring">
</span>use serde::Deserialize;

use std::borrow::Cow;

#[derive(Deserialize)]
struct Inner&lt;'a, 'b&gt; {
    // &amp;str and &amp;[u8] are implicitly borrowed.
    username: &amp;'a str,

    // Other types must be borrowed explicitly.
    #[serde(borrow)]
    comment: Cow&lt;'b, str&gt;,
}

#[derive(Deserialize)]
struct Outer&lt;'a, 'b, 'c&gt; {
    owned: String,

    #[serde(borrow)]
    inner: Inner&lt;'a, 'b&gt;,

    // This field is never borrowed.
    not_borrowed: Cow&lt;'c, str&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>This attribute works by placing bounds on the <code>'de</code> lifetime of the generated
<code>Deserialize</code> impl. For example the impl for the struct <code>Outer</code> defined above
looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(dead_code)]
</span><span class="boring">
</span><span class="boring">use std::borrow::Cow;
</span><span class="boring">
</span><span class="boring">trait Deserialize&lt;'de&gt; {}
</span><span class="boring">
</span><span class="boring">struct Inner&lt;'a, 'b&gt; {
</span><span class="boring">    username: &amp;'a str,
</span><span class="boring">    comment: Cow&lt;'b, str&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Outer&lt;'a, 'b, 'c&gt; {
</span><span class="boring">    owned: String,
</span><span class="boring">    inner: Inner&lt;'a, 'b&gt;,
</span><span class="boring">    not_borrowed: Cow&lt;'c, str&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// The lifetimes 'a and 'b are borrowed while 'c is not.
impl&lt;'de: 'a + 'b, 'a, 'b, 'c&gt; Deserialize&lt;'de&gt; for Outer&lt;'a, 'b, 'c&gt; {
    /* ... */
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>The attribute may specify explicitly which lifetimes should be borrowed.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(dead_code)]
</span><span class="boring">
</span><span class="boring">use serde::Deserialize;
</span><span class="boring">
</span>use std::marker::PhantomData;

// This struct borrows the first two lifetimes but not the third.
#[derive(Deserialize)]
struct Three&lt;'a, 'b, 'c&gt; {
    a: &amp;'a str,
    b: &amp;'b str,
    c: PhantomData&lt;&amp;'c str&gt;,
}

#[derive(Deserialize)]
struct Example&lt;'a, 'b, 'c&gt; {
    // Borrow 'a and 'b only, not 'c.
    #[serde(borrow = &quot;'a + 'b&quot;)]
    three: Three&lt;'a, 'b, 'c&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p><strong><a href="json.html">Structs and enums in JSON</a></strong>: The representation chosen by
<a href="https://github.com/serde-rs/json"><code>serde_json</code></a> for structs and enums. Other
human-readable data formats are encouraged to follow an analogous approach where
possible.</p>
<p><strong><a href="enum-representations.html">Enum representations</a></strong>: Externally tagged,
internally tagged, adjacently tagged, and untagged ways of representing an enum
in self-describing formats.</p>
<p><strong><a href="attr-default.html">Default value for a field</a></strong>: Some examples of the
<code>#[serde(default)]</code> attribute.</p>
<p><strong><a href="attr-bound.html">Handwritten generic type bounds</a></strong>: Some unusual scenarios in
which Serde's derive infers the wrong generic type bounds. The impl bounds can
be replaced with handwritten ones using the <code>#[serde(bound)]</code> attribute.</p>
<p><strong><a href="deserialize-map.html">Deserialize for custom map type</a></strong>: Detailed explanation
of each step involved in deserializing a map.</p>
<p><strong><a href="stream-array.html">Array of values without buffering</a></strong>: Deserialize the
maximum value of an array of integers without holding the whole array in memory
at once. This approach can be adapted to handle a variety of other situations in
which data needs to be processed while being deserialized instead of after.</p>
<p><strong><a href="enum-number.html">Serialize enum as number</a></strong>: A macro to impl <code>Serialize</code> and
<code>Deserialize</code> for a C-like enum in a way that represents it as a <code>u64</code> across
all data formats.</p>
<p><strong><a href="attr-rename.html">Serialize fields as camelCase</a></strong>: One common application of
the <code>#[serde(rename)]</code> attribute.</p>
<p><strong><a href="attr-skip-serializing.html">Skip serializing field</a></strong>: Some examples of the
<code>#[serde(skip_serializing)]</code> and <code>#[serde(skip_serializing_if)]</code> attributes.</p>
<p><strong><a href="remote-derive.html">Derive for remote crate</a></strong>: Deriving <code>Serialize</code> and
<code>Deserialize</code> implementations for a type in somebody else's crate.</p>
<p><strong><a href="deserialize-struct.html">Manually deserialize struct</a></strong>: The long form of the
<code>Deserialize</code> impl generated by derive for a simple struct.</p>
<p><strong><a href="ignored-any.html">Discarding data</a></strong>: Using <code>IgnoredAny</code> to efficiently discard
data from a deserializer.</p>
<p><strong><a href="transcode.html">Transcode one format into another</a></strong>: Use the
<a href="https://github.com/sfackler/serde-transcode">serde-transcode</a> crate to stream
input in one format to output in another format efficiently.</p>
<p><strong><a href="string-or-struct.html">Deserialize either a string or a struct</a></strong>: The
<a href="https://docs.docker.com/compose/compose-file/#/build"><code>docker-compose.yml</code></a>
configuration file has a &quot;build&quot; key which can be either a string or a struct.</p>
<p><strong><a href="convert-error.html">Convert error types</a></strong>: Map a Serde error from some format
into a Serde error for some other format using <code>Error::custom</code>.</p>
<p><strong><a href="custom-date-format.html">Date in a custom format</a></strong>: Handle a
<a href="https://github.com/chronotope/chrono"><code>chrono</code></a> <code>DateTime</code> formatted with a
custom string representation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs-and-enums-in-json"><a class="header" href="#structs-and-enums-in-json">Structs and enums in JSON</a></h1>
<p>A Serde <code>Serializer</code> is responsible for selecting the convention by which Rust
structs and enums are represented in that format. Here are the conventions
selected by the <a href="https://github.com/serde-rs/json"><code>serde_json</code></a> data format.
For consistency, other human-readable formats are encouraged to develop
analogous conventions where possible.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(dead_code, unused_variables)]
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">
</span>struct W {
    a: i32,
    b: i32,
}
let w = W { a: 0, b: 0 }; // Represented as `{&quot;a&quot;:0,&quot;b&quot;:0}`

struct X(i32, i32);
let x = X(0, 0); // Represented as `[0,0]`

struct Y(i32);
let y = Y(0); // Represented as just the inner value `0`

struct Z;
let z = Z; // Represented as `null`

enum E {
    W { a: i32, b: i32 },
    X(i32, i32),
    Y(i32),
    Z,
}
let w = E::W { a: 0, b: 0 }; // Represented as `{&quot;W&quot;:{&quot;a&quot;:0,&quot;b&quot;:0}}`
let x = E::X(0, 0);          // Represented as `{&quot;X&quot;:[0,0]}`
let y = E::Y(0);             // Represented as `{&quot;Y&quot;:0}`
let z = E::Z;                // Represented as `&quot;Z&quot;`
<span class="boring">
</span><span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enum-representations"><a class="header" href="#enum-representations">Enum representations</a></h1>
<p>Consider the following enum type:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">use serde::{Serialize, Deserialize};
</span><span class="boring">
</span><span class="boring">type Params = ();
</span><span class="boring">type Value = ();
</span><span class="boring">
</span>#[derive(Serialize, Deserialize)]
enum Message {
    Request { id: String, method: String, params: Params },
    Response { id: String, result: Value },
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="externally-tagged"><a class="header" href="#externally-tagged">Externally tagged</a></h2>
<p>The default representation for this enum in Serde is called the externally
tagged enum representation. Written in JSON syntax it looks like:</p>
<pre><code class="language-json">{&quot;Request&quot;: {&quot;id&quot;: &quot;...&quot;, &quot;method&quot;: &quot;...&quot;, &quot;params&quot;: {...}}}
</code></pre>
<p>The externally tagged representation is characterized by being able to know
which variant we are dealing with before beginning to parse the content of the
variant. This property allows it to work across a broad range of text and binary
formats. The <code>Serializer::serialize_*_variant</code> and
<code>Deserializer::deserialize_enum</code> methods use an externally tagged
representation.</p>
<p>This representation can handle any type of variant: struct variants like above,
tuple variants, newtype variants, and unit variants.</p>
<p>In JSON and other self-describing formats, the externally tagged representation
is often not ideal for readability. Serde provides attributes to select three
other possible representations.</p>
<h2 id="internally-tagged"><a class="header" href="#internally-tagged">Internally tagged</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">use serde::{Serialize, Deserialize};
</span><span class="boring">
</span><span class="boring">type Params = ();
</span><span class="boring">type Value = ();
</span><span class="boring">
</span>#[derive(Serialize, Deserialize)]
#[serde(tag = &quot;type&quot;)]
enum Message {
    Request { id: String, method: String, params: Params },
    Response { id: String, result: Value },
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Written in JSON syntax, the internally tagged representation looks like this:</p>
<pre><code class="language-json">{&quot;type&quot;: &quot;Request&quot;, &quot;id&quot;: &quot;...&quot;, &quot;method&quot;: &quot;...&quot;, &quot;params&quot;: {...}}
</code></pre>
<p>The tag identifying which variant we are dealing with is now inside of the
content, next to any other fields of the variant. This representation is common
in Java libraries.</p>
<p>This representation works for struct variants, newtype variants containing
structs or maps, and unit variants but does not work for enums containing tuple
variants. Using a <code>#[serde(tag = &quot;...&quot;)]</code> attribute on an enum containing a
tuple variant is an error at compile time.</p>
<h2 id="adjacently-tagged"><a class="header" href="#adjacently-tagged">Adjacently tagged</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">use serde::{Serialize, Deserialize};
</span><span class="boring">
</span><span class="boring">type Inline = ();
</span><span class="boring">
</span>#[derive(Serialize, Deserialize)]
#[serde(tag = &quot;t&quot;, content = &quot;c&quot;)]
enum Block {
    Para(Vec&lt;Inline&gt;),
    Str(String),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>This representation is common in the Haskell world. Written in JSON syntax:</p>
<pre><code class="language-json">{&quot;t&quot;: &quot;Para&quot;, &quot;c&quot;: [{...}, {...}]}
{&quot;t&quot;: &quot;Str&quot;, &quot;c&quot;: &quot;the string&quot;}
</code></pre>
<p>The tag and the content are adjacent to each other as two fields within the same
object.</p>
<h2 id="untagged"><a class="header" href="#untagged">Untagged</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">use serde::{Serialize, Deserialize};
</span><span class="boring">
</span><span class="boring">type Params = ();
</span><span class="boring">type Value = ();
</span><span class="boring">
</span>#[derive(Serialize, Deserialize)]
#[serde(untagged)]
enum Message {
    Request { id: String, method: String, params: Params },
    Response { id: String, result: Value },
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Written in JSON syntax, the untagged representation looks like this:</p>
<pre><code class="language-json">{&quot;id&quot;: &quot;...&quot;, &quot;method&quot;: &quot;...&quot;, &quot;params&quot;: {...}}
</code></pre>
<p>There is no explicit tag identifying which variant the data contains. Serde will
try to match the data against each variant in order and the first one that
deserializes successfully is the one returned.</p>
<p>This representation can handle enums containing any type of variant.</p>
<p>As another example of an untagged enum, this enum can be deserialized from
either an integer or an array of two strings:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">use serde::{Serialize, Deserialize};
</span><span class="boring">
</span>#[derive(Serialize, Deserialize)]
#[serde(untagged)]
enum Data {
    Integer(u64),
    Pair(String, String),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="default-value-for-a-field"><a class="header" href="#default-value-for-a-field">Default value for a field</a></h1>
<pre><pre class="playground"><code class="language-rust edition2018">use serde::Deserialize;

#[derive(Deserialize, Debug)]
struct Request {
    // Use the result of a function as the default if &quot;resource&quot; is
    // not included in the input.
    #[serde(default = &quot;default_resource&quot;)]
    resource: String,

    // Use the type's implementation of std::default::Default if
    // &quot;timeout&quot; is not included in the input.
    #[serde(default)]
    timeout: Timeout,

    // Use a method from the type as the default if &quot;priority&quot; is not
    // included in the input. This may also be a trait method.
    #[serde(default = &quot;Priority::lowest&quot;)]
    priority: Priority,
}

fn default_resource() -&gt; String {
    &quot;/&quot;.to_string()
}

/// Timeout in seconds.
#[derive(Deserialize, Debug)]
struct Timeout(u32);
impl Default for Timeout {
    fn default() -&gt; Self {
        Timeout(30)
    }
}

#[derive(Deserialize, Debug)]
enum Priority { ExtraHigh, High, Normal, Low, ExtraLow }
impl Priority {
    fn lowest() -&gt; Self { Priority::ExtraLow }
}

fn main() {
    let json = r#&quot;
        [
          {
            &quot;resource&quot;: &quot;/users&quot;
          },
          {
            &quot;timeout&quot;: 5,
            &quot;priority&quot;: &quot;High&quot;
          }
        ]
    &quot;#;

    let requests: Vec&lt;Request&gt; = serde_json::from_str(json).unwrap();

    // The first request has resource=&quot;/users&quot;, timeout=30, priority=ExtraLow
    println!(&quot;{:?}&quot;, requests[0]);

    // The second request has resource=&quot;/&quot;, timeout=5, priority=High
    println!(&quot;{:?}&quot;, requests[1]);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-flattening"><a class="header" href="#struct-flattening">Struct flattening</a></h1>
<p>The <code>flatten</code> attribute inlines keys from a field into the parent struct.
<code>flatten</code> may be used any number of times within the same struct. It is
supported only within structs that have named fields, and the field to which it
is applied must be a struct or map type.</p>
<p><em>Note:</em> <code>flatten</code> is not supported in combination with structs that use
<a href="container-attrs.html#deny_unknown_fields"><code>deny_unknown_fields</code></a>. Neither the outer nor inner flattened struct should use
that attribute.</p>
<p>The <code>flatten</code> attribute serves the following two common use cases:</p>
<h3 id="factor-out-frequently-grouped-keys"><a class="header" href="#factor-out-frequently-grouped-keys">Factor out frequently grouped keys</a></h3>
<p>Consider a paginated API which returns a page of results along with pagination
metadata that identifies how many results were requested, how far into the total
set of results we are looking at, and how many results exist in total. If we are
paging through a total of 1053 results 100 at a time, the third page may look
like this.</p>
<pre><code class="language-json">{
  &quot;limit&quot;: 100,
  &quot;offset&quot;: 200,
  &quot;total&quot;: 1053,
  &quot;users&quot;: [
    {&quot;id&quot;: &quot;49824073-979f-4814-be10-5ea416ee1c2f&quot;, &quot;username&quot;: &quot;john_doe&quot;},
    ...
  ]
}
</code></pre>
<p>This same scheme with <code>&quot;limit&quot;</code> and <code>&quot;offset&quot;</code> and <code>&quot;total&quot;</code> fields may be
shared across lots of different API queries. For example we may want paginated
results when querying for users, for issues, for projects, etc.</p>
<p>In this case it can be convenient to factor the common pagination metadata fields
into a shared struct that can be flattened into each API response object.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">use serde::{Serialize, Deserialize};
</span><span class="boring">
</span>#[derive(Serialize, Deserialize)]
struct Pagination {
    limit: u64,
    offset: u64,
    total: u64,
}

#[derive(Serialize, Deserialize)]
struct Users {
    users: Vec&lt;User&gt;,

    #[serde(flatten)]
    pagination: Pagination,
}
<span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize)]
</span><span class="boring">struct User;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h3 id="capture-additional-fields"><a class="header" href="#capture-additional-fields">Capture additional fields</a></h3>
<p>A field of map type can be flattened to hold additional data that is not
captured by any other fields of the struct.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use serde_json::Value;

#[derive(Serialize, Deserialize)]
struct User {
    id: String,
    username: String,

    #[serde(flatten)]
    extra: HashMap&lt;String, Value&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>For example if we fill the flattened <code>extra</code> field with the key <code>&quot;mascot&quot;: &quot;Ferris&quot;</code>, it would serialize to the following JSON representation.</p>
<pre><code class="language-json">{
  &quot;id&quot;: &quot;49824073-979f-4814-be10-5ea416ee1c2f&quot;,
  &quot;username&quot;: &quot;john_doe&quot;,
  &quot;mascot&quot;: &quot;Ferris&quot;
}
</code></pre>
<p>Deserialization of this data would populate <code>&quot;mascot&quot;</code> back into the flattened
<code>extra</code> field. This way additional data in an object can be collected for later
processing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handwritten-generic-type-bounds"><a class="header" href="#handwritten-generic-type-bounds">Handwritten generic type bounds</a></h1>
<p>When deriving <code>Serialize</code> and <code>Deserialize</code> implementations for structs with
generic type parameters, most of the time Serde is able to infer the correct
trait bounds without help from the programmer. It uses several heuristics to
guess the right bound, but most importantly it puts a bound of <code>T: Serialize</code> on
every type parameter <code>T</code> that is part of a serialized field and a bound of <code>T: Deserialize</code> on every type parameter <code>T</code> that is part of a deserialized field.
As with most heuristics, this is not always right and Serde provides an escape
hatch to replace the automatically generated bound by one written by the
programmer.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use serde::{de, Deserialize, Deserializer};

use std::fmt::Display;
use std::str::FromStr;

#[derive(Deserialize, Debug)]
struct Outer&lt;'a, S, T: 'a + ?Sized&gt; {
    // When deriving the Deserialize impl, Serde would want to generate a bound
    // `S: Deserialize` on the type of this field. But we are going to use the
    // type's `FromStr` impl instead of its `Deserialize` impl by going through
    // `deserialize_from_str`, so we override the automatically generated bound
    // by the one required for `deserialize_from_str`.
    #[serde(deserialize_with = &quot;deserialize_from_str&quot;)]
    #[serde(bound(deserialize = &quot;S: FromStr, S::Err: Display&quot;))]
    s: S,

    // Here Serde would want to generate a bound `T: Deserialize`. That is a
    // stricter condition than is necessary. In fact, the `main` function below
    // uses T=str which does not implement Deserialize. We override the
    // automatically generated bound by a looser one.
    #[serde(bound(deserialize = &quot;Ptr&lt;'a, T&gt;: Deserialize&lt;'de&gt;&quot;))]
    ptr: Ptr&lt;'a, T&gt;,
}

/// Deserialize a type `S` by deserializing a string, then using the `FromStr`
/// impl of `S` to create the result. The generic type `S` is not required to
/// implement `Deserialize`.
fn deserialize_from_str&lt;'de, S, D&gt;(deserializer: D) -&gt; Result&lt;S, D::Error&gt;
where
    S: FromStr,
    S::Err: Display,
    D: Deserializer&lt;'de&gt;,
{
    let s: String = Deserialize::deserialize(deserializer)?;
    S::from_str(&amp;s).map_err(de::Error::custom)
}

/// A pointer to `T` which may or may not own the data. When deserializing we
/// always want to produce owned data.
#[derive(Debug)]
enum Ptr&lt;'a, T: 'a + ?Sized&gt; {
<span class="boring">    #[allow(dead_code)]
</span>    Ref(&amp;'a T),
    Owned(Box&lt;T&gt;),
}

impl&lt;'de, 'a, T: 'a + ?Sized&gt; Deserialize&lt;'de&gt; for Ptr&lt;'a, T&gt;
where
    Box&lt;T&gt;: Deserialize&lt;'de&gt;,
{
    fn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Self, D::Error&gt;
    where
        D: Deserializer&lt;'de&gt;,
    {
        Deserialize::deserialize(deserializer).map(Ptr::Owned)
    }
}

fn main() {
    let j = r#&quot;
        {
            &quot;s&quot;: &quot;1234567890&quot;,
            &quot;ptr&quot;: &quot;owned&quot;
        }
    &quot;#;

    let result: Outer&lt;u64, str&gt; = serde_json::from_str(j).unwrap();

    // result = Outer { s: 1234567890, ptr: Owned(&quot;owned&quot;) }
    println!(&quot;result = {:?}&quot;, result);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implement-deserialize-for-a-custom-map-type"><a class="header" href="#implement-deserialize-for-a-custom-map-type">Implement Deserialize for a custom map type</a></h1>
<pre><pre class="playground"><code class="language-rust edition2018">use std::fmt;
use std::marker::PhantomData;

use serde::de::{Deserialize, Deserializer, Visitor, MapAccess};
<span class="boring">
</span><span class="boring">struct MyMap&lt;K, V&gt;(PhantomData&lt;K&gt;, PhantomData&lt;V&gt;);
</span><span class="boring">
</span><span class="boring">impl&lt;K, V&gt; MyMap&lt;K, V&gt; {
</span><span class="boring">    fn with_capacity(_: usize) -&gt; Self {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn insert(&amp;mut self, _: K, _: V) {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">}
</span>
// A Visitor is a type that holds methods that a Deserializer can drive
// depending on what is contained in the input data.
//
// In the case of a map we need generic type parameters K and V to be
// able to set the output type correctly, but don't require any state.
// This is an example of a &quot;zero sized type&quot; in Rust. The PhantomData
// keeps the compiler from complaining about unused generic type
// parameters.
struct MyMapVisitor&lt;K, V&gt; {
    marker: PhantomData&lt;fn() -&gt; MyMap&lt;K, V&gt;&gt;
}

impl&lt;K, V&gt; MyMapVisitor&lt;K, V&gt; {
    fn new() -&gt; Self {
        MyMapVisitor {
            marker: PhantomData
        }
    }
}

// This is the trait that Deserializers are going to be driving. There
// is one method for each type of data that our type knows how to
// deserialize from. There are many other methods that are not
// implemented here, for example deserializing from integers or strings.
// By default those methods will return an error, which makes sense
// because we cannot deserialize a MyMap from an integer or string.
impl&lt;'de, K, V&gt; Visitor&lt;'de&gt; for MyMapVisitor&lt;K, V&gt;
where
    K: Deserialize&lt;'de&gt;,
    V: Deserialize&lt;'de&gt;,
{
    // The type that our Visitor is going to produce.
    type Value = MyMap&lt;K, V&gt;;

    // Format a message stating what data this Visitor expects to receive.
    fn expecting(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        formatter.write_str(&quot;a very special map&quot;)
    }

    // Deserialize MyMap from an abstract &quot;map&quot; provided by the
    // Deserializer. The MapAccess input is a callback provided by
    // the Deserializer to let us see each entry in the map.
    fn visit_map&lt;M&gt;(self, mut access: M) -&gt; Result&lt;Self::Value, M::Error&gt;
    where
        M: MapAccess&lt;'de&gt;,
    {
        let mut map = MyMap::with_capacity(access.size_hint().unwrap_or(0));

        // While there are entries remaining in the input, add them
        // into our map.
        while let Some((key, value)) = access.next_entry()? {
            map.insert(key, value);
        }

        Ok(map)
    }
}

// This is the trait that informs Serde how to deserialize MyMap.
impl&lt;'de, K, V&gt; Deserialize&lt;'de&gt; for MyMap&lt;K, V&gt;
where
    K: Deserialize&lt;'de&gt;,
    V: Deserialize&lt;'de&gt;,
{
    fn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Self, D::Error&gt;
    where
        D: Deserializer&lt;'de&gt;,
    {
        // Instantiate our Visitor and ask the Deserializer to drive
        // it over the input data, resulting in an instance of MyMap.
        deserializer.deserialize_map(MyMapVisitor::new())
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="process-an-array-of-values-without-buffering-into-a-vec"><a class="header" href="#process-an-array-of-values-without-buffering-into-a-vec">Process an array of values without buffering into a Vec</a></h1>
<p>Suppose we have an array of integers and we want to figure out the maximum value
without holding the whole array in memory all at once. This approach can be
adapted to handle a variety of other situations in which data needs to be
processed while being deserialized instead of after.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use serde::{Deserialize, Deserializer};
use serde::de::{self, Visitor, SeqAccess};

use std::{cmp, fmt};
use std::marker::PhantomData;

#[derive(Deserialize)]
struct Outer {
<span class="boring">    #[allow(dead_code)]
</span>    id: String,

    // Deserialize this field by computing the maximum value of a sequence
    // (JSON array) of values.
    #[serde(deserialize_with = &quot;deserialize_max&quot;)]
    // Despite the struct field being named `max_value`, it is going to come
    // from a JSON field called `values`.
    #[serde(rename(deserialize = &quot;values&quot;))]
    max_value: u64,
}

/// Deserialize the maximum of a sequence of values. The entire sequence
/// is not buffered into memory as it would be if we deserialize to Vec&lt;T&gt;
/// and then compute the maximum later.
///
/// This function is generic over T which can be any type that implements
/// Ord. Above, it is used with T=u64.
fn deserialize_max&lt;'de, T, D&gt;(deserializer: D) -&gt; Result&lt;T, D::Error&gt;
where
    T: Deserialize&lt;'de&gt; + Ord,
    D: Deserializer&lt;'de&gt;,
{
    struct MaxVisitor&lt;T&gt;(PhantomData&lt;fn() -&gt; T&gt;);

    impl&lt;'de, T&gt; Visitor&lt;'de&gt; for MaxVisitor&lt;T&gt;
    where
        T: Deserialize&lt;'de&gt; + Ord,
    {
        /// Return type of this visitor. This visitor computes the max of a
        /// sequence of values of type T, so the type of the maximum is T.
        type Value = T;

        fn expecting(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {
            formatter.write_str(&quot;a nonempty sequence of numbers&quot;)
        }

        fn visit_seq&lt;S&gt;(self, mut seq: S) -&gt; Result&lt;T, S::Error&gt;
        where
            S: SeqAccess&lt;'de&gt;,
        {
            // Start with max equal to the first value in the seq.
            let mut max = seq.next_element()?.ok_or_else(||
                // Cannot take the maximum of an empty seq.
                de::Error::custom(&quot;no values in seq when looking for maximum&quot;)
            )?;

            // Update the max while there are additional values.
            while let Some(value) = seq.next_element()? {
                max = cmp::max(max, value);
            }

            Ok(max)
        }
    }

    // Create the visitor and ask the deserializer to drive it. The
    // deserializer will call visitor.visit_seq() if a seq is present in
    // the input data.
    let visitor = MaxVisitor(PhantomData);
    deserializer.deserialize_seq(visitor)
}

fn main() {
    let j = r#&quot;
        {
          &quot;id&quot;: &quot;demo-deserialize-max&quot;,
          &quot;values&quot;: [
            256,
            100,
            384,
            314,
            271
          ]
        }
    &quot;#;

    let out: Outer = serde_json::from_str(j).unwrap();

    // Prints &quot;max value: 384&quot;
    println!(&quot;max value: {}&quot;, out.max_value);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serialize-enum-as-number"><a class="header" href="#serialize-enum-as-number">Serialize enum as number</a></h1>
<p>The <a href="https://github.com/dtolnay/serde-repr">serde_repr</a> crate provides alternative derive macros that derive the same
Serialize and Deserialize traits but delegate to the underlying representation
of a C-like enum. This allows C-like enums to be formatted as integers rather
than strings in JSON, for example.</p>
<pre><code class="language-toml">[dependencies]
serde = &quot;1.0&quot;
serde_json = &quot;1.0&quot;
serde_repr = &quot;0.1&quot;
</code></pre>
<pre><code class="language-rust noplayground">use serde_repr::*;

#[derive(Serialize_repr, Deserialize_repr, PartialEq, Debug)]
#[repr(u8)]
enum SmallPrime {
    Two = 2,
    Three = 3,
    Five = 5,
    Seven = 7,
}

fn main() {
    use SmallPrime::*;
    let nums = vec![Two, Three, Five, Seven];

    // Prints [2,3,5,7]
    println!(&quot;{}&quot;, serde_json::to_string(&amp;nums).unwrap());

    assert_eq!(Two, serde_json::from_str(&quot;2&quot;).unwrap());
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serialize-fields-as-camelcase"><a class="header" href="#serialize-fields-as-camelcase">Serialize fields as camelCase</a></h1>
<pre><pre class="playground"><code class="language-rust edition2018">use serde::Serialize;

#[derive(Serialize)]
#[serde(rename_all = &quot;camelCase&quot;)]
struct Person {
    first_name: String,
    last_name: String,
}

fn main() {
    let person = Person {
        first_name: &quot;Graydon&quot;.to_string(),
        last_name: &quot;Hoare&quot;.to_string(),
    };

    let json = serde_json::to_string_pretty(&amp;person).unwrap();

    // Prints:
    //
    //    {
    //      &quot;firstName&quot;: &quot;Graydon&quot;,
    //      &quot;lastName&quot;: &quot;Hoare&quot;
    //    }
    println!(&quot;{}&quot;, json);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="skip-serializing-field"><a class="header" href="#skip-serializing-field">Skip serializing field</a></h1>
<p><strong>NOTE:</strong> Using <code>skip_serializing</code> does not skip <strong>de</strong>serializing the field. If
you only add the <code>skip_serializing</code> attribute, and then attempt to deserialize
the data, it will fail, as it will still attempt to deserialize the skipped
field. Please use the <code>skip</code> attribute to skip <strong>both</strong> serializing and
deserializing (see <a href="field-attrs.html#skip">Field Attributes: <code>skip</code></a>). Likewise, use
<code>skip_deserializing</code> to skip deserializing only.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use serde::Serialize;

use std::collections::BTreeMap as Map;

#[derive(Serialize)]
struct Resource {
    // Always serialized.
    name: String,

    // Never serialized.
    #[serde(skip_serializing)]
<span class="boring">    #[allow(dead_code)]
</span>    hash: String,

    // Use a method to decide whether the field should be skipped.
    #[serde(skip_serializing_if = &quot;Map::is_empty&quot;)]
    metadata: Map&lt;String, String&gt;,
}

fn main() {
    let resources = vec![
        Resource {
            name: &quot;Stack Overflow&quot;.to_string(),
            hash: &quot;b6469c3f31653d281bbbfa6f94d60fea130abe38&quot;.to_string(),
            metadata: Map::new(),
        },
        Resource {
            name: &quot;GitHub&quot;.to_string(),
            hash: &quot;5cb7a0c47e53854cd00e1a968de5abce1c124601&quot;.to_string(),
            metadata: {
                let mut metadata = Map::new();
                metadata.insert(&quot;headquarters&quot;.to_string(),
                                &quot;San Francisco&quot;.to_string());
                metadata
            },
        },
    ];

    let json = serde_json::to_string_pretty(&amp;resources).unwrap();

    // Prints:
    //
    //    [
    //      {
    //        &quot;name&quot;: &quot;Stack Overflow&quot;
    //      },
    //      {
    //        &quot;name&quot;: &quot;GitHub&quot;,
    //        &quot;metadata&quot;: {
    //          &quot;headquarters&quot;: &quot;San Francisco&quot;
    //        }
    //      }
    //    ]
    println!(&quot;{}&quot;, json);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deriving-deserialize-for-type-in-a-different-crate"><a class="header" href="#deriving-deserialize-for-type-in-a-different-crate">Deriving De/Serialize for type in a different crate</a></h1>
<p>Rust's <a href="https://doc.rust-lang.org/book/traits.html#rules-for-implementing-traits">orphan rule</a> requires that either the trait or the type for which you
are implementing the trait must be defined in the same crate as the impl, so it
is not possible to implement <code>Serialize</code> and <code>Deserialize</code> for a type in a
different crate directly.</p>
<pre><code class="language-diff">- use serde::Serialize;
- use other_crate::Duration;
-
- // Not allowed by orphan rule.
- impl Serialize for Duration {
-     /* ... */
- }
</code></pre>
<p>To work around this, Serde provides a way of deriving <code>Serialize</code> and
<code>Deserialize</code> implementations for types in other people's crates. The only catch
is that you have to provide a definition of the type for Serde's derive to
process. At compile time, Serde will check that all the fields in the definition
you provided match the fields in the remote type.</p>
<pre><pre class="playground"><code class="language-rust edition2018">// Pretend that this is somebody else's crate, not a module.
mod other_crate {
    // Neither Serde nor the other crate provides Serialize and Deserialize
    // impls for this struct.
    pub struct Duration {
        pub secs: i64,
        pub nanos: i32,
    }
}

////////////////////////////////////////////////////////////////////////////////

use other_crate::Duration;
use serde::{Serialize, Deserialize};

// Serde calls this the definition of the remote type. It is just a copy of the
// remote data structure. The `remote` attribute gives the path to the actual
// type we intend to derive code for.
#[derive(Serialize, Deserialize)]
#[serde(remote = &quot;Duration&quot;)]
struct DurationDef {
    secs: i64,
    nanos: i32,
}

// Now the remote type can be used almost like it had its own Serialize and
// Deserialize impls all along. The `with` attribute gives the path to the
// definition for the remote type. Note that the real type of the field is the
// remote type, not the definition type.
#[derive(Serialize, Deserialize)]
struct Process {
    command_line: String,

    #[serde(with = &quot;DurationDef&quot;)]
    wall_time: Duration,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>If the remote type is a struct with all public fields or an enum, that's all
there is to it. If the remote type is a struct with one or more private fields,
getters must be provided for the private fields and a conversion must be
provided to construct the remote type.</p>
<pre><pre class="playground"><code class="language-rust edition2018">// Pretend that this is somebody else's crate, not a module.
mod other_crate {
    // Neither Serde nor the other crate provides Serialize and Deserialize
    // impls for this struct. Oh, and the fields are private.
    pub struct Duration {
        secs: i64,
        nanos: i32,
    }

    impl Duration {
        pub fn new(secs: i64, nanos: i32) -&gt; Self {
            Duration { secs: secs, nanos: nanos }
        }

        pub fn seconds(&amp;self) -&gt; i64 {
            self.secs
        }

        pub fn subsec_nanos(&amp;self) -&gt; i32 {
            self.nanos
        }
    }
}

////////////////////////////////////////////////////////////////////////////////

use other_crate::Duration;
use serde::{Serialize, Deserialize};

// Provide getters for every private field of the remote struct. The getter must
// return either `T` or `&amp;T` where `T` is the type of the field.
#[derive(Serialize, Deserialize)]
#[serde(remote = &quot;Duration&quot;)]
struct DurationDef {
    #[serde(getter = &quot;Duration::seconds&quot;)]
    secs: i64,
    #[serde(getter = &quot;Duration::subsec_nanos&quot;)]
    nanos: i32,
}

// Provide a conversion to construct the remote type.
impl From&lt;DurationDef&gt; for Duration {
    fn from(def: DurationDef) -&gt; Duration {
        Duration::new(def.secs, def.nanos)
    }
}

#[derive(Serialize, Deserialize)]
struct Process {
    command_line: String,

    #[serde(with = &quot;DurationDef&quot;)]
    wall_time: Duration,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="invoking-the-remote-impl-directly"><a class="header" href="#invoking-the-remote-impl-directly">Invoking the remote impl directly</a></h2>
<p>As shown above, the remote impl is intended to be invoked through a
<code>#[serde(with = &quot;...&quot;)]</code> attribute on a field of some other struct.</p>
<p>Invoking the remote impl directly, such as if this is the top-level type being
serialized or deserialized, is somewhat more complicated because of the orphan
rules as mentioned. The code ultimately generated by these remote derives are
not <code>Serialize</code> and <code>Deserialize</code> impls but associated functions with the same
signature.</p>
<pre><code class="language-rust noplayground"><span class="boring">#![allow(dead_code)]
</span><span class="boring">
</span><span class="boring">use serde::Deserialize;
</span><span class="boring">
</span><span class="boring">struct Duration {
</span><span class="boring">    secs: i64,
</span><span class="boring">    nanos: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// Technically this derive does not produce a Deserialize impl for Duration, nor
// a Deserialize impl for DurationDef.
//
// Instead it produces a deserialization method DurationDef::deserialize whose
// return type is Duration. The method has the same signature as a Deserialize
// impl for Duration would have but is not a Deserialize impl.
#[derive(Deserialize)]
#[serde(remote = &quot;Duration&quot;)]
struct DurationDef {
    secs: i64,
    nanos: i32,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>Knowing this, the generated method can be invoked directly by passing a
<code>Deserializer</code> implementation.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(dead_code)]
</span><span class="boring">
</span><span class="boring">use serde::Deserialize;
</span><span class="boring">
</span><span class="boring">struct Duration;
</span><span class="boring">
</span><span class="boring">#[derive(Deserialize)]
</span><span class="boring">#[serde(remote = &quot;Duration&quot;)]
</span><span class="boring">struct DurationDef;
</span><span class="boring">
</span><span class="boring">fn try_main(j: &amp;str) -&gt; Result&lt;Duration, serde_json::Error&gt; {
</span>let mut de = serde_json::Deserializer::from_str(j);
let dur = DurationDef::deserialize(&amp;mut de)?;

// `dur` has type Duration
<span class="boring">    Ok(dur)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Alternatively we can write a top-level newtype wrapper as a private helper for
deserializing the remote type.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(dead_code)]
</span><span class="boring">
</span><span class="boring">use serde::Deserialize;
</span><span class="boring">
</span><span class="boring">struct Duration;
</span><span class="boring">
</span><span class="boring">#[derive(Deserialize)]
</span><span class="boring">#[serde(remote = &quot;Duration&quot;)]
</span><span class="boring">struct DurationDef;
</span><span class="boring">
</span><span class="boring">fn try_main(j: &amp;str) -&gt; Result&lt;Duration, serde_json::Error&gt; {
</span>#[derive(Deserialize)]
struct Helper(#[serde(with = &quot;DurationDef&quot;)] Duration);

let dur = serde_json::from_str(j).map(|Helper(dur)| dur)?;

// `dur` has type Duration
<span class="boring">    Ok(dur)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manually-implementing-deserialize-for-a-struct"><a class="header" href="#manually-implementing-deserialize-for-a-struct">Manually implementing Deserialize for a struct</a></h1>
<p>Only when <a href="derive.html">derive</a> is not getting the job done.</p>
<p>The <code>Deserialize</code> impl below corresponds to the following struct:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#[allow(dead_code)]
</span>struct Duration {
    secs: u64,
    nanos: u32,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Deserializing a struct is somewhat more complicated than <a href="deserialize-map.html">deserializing a
map</a> in order to avoid allocating a String to hold the field
names. Instead there is a <code>Field</code> enum which is deserialized from a <code>&amp;str</code>.</p>
<p>The implementation supports two possible ways that a struct may be represented
by a data format: as a seq like in Bincode, and as a map like in JSON.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use std::fmt;

use serde::de::{self, Deserialize, Deserializer, Visitor, SeqAccess, MapAccess};

<span class="boring">#[allow(dead_code)]
</span><span class="boring">struct Duration {
</span><span class="boring">    secs: u64,
</span><span class="boring">    nanos: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Duration {
</span><span class="boring">    fn new(_: u64, _: u32) -&gt; Self {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'de&gt; Deserialize&lt;'de&gt; for Duration {
    fn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Self, D::Error&gt;
    where
        D: Deserializer&lt;'de&gt;,
    {
        enum Field { Secs, Nanos }

        // This part could also be generated independently by:
        //
        //    #[derive(Deserialize)]
        //    #[serde(field_identifier, rename_all = &quot;lowercase&quot;)]
        //    enum Field { Secs, Nanos }
        impl&lt;'de&gt; Deserialize&lt;'de&gt; for Field {
            fn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Field, D::Error&gt;
            where
                D: Deserializer&lt;'de&gt;,
            {
                struct FieldVisitor;

                impl&lt;'de&gt; Visitor&lt;'de&gt; for FieldVisitor {
                    type Value = Field;

                    fn expecting(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {
                        formatter.write_str(&quot;`secs` or `nanos`&quot;)
                    }

                    fn visit_str&lt;E&gt;(self, value: &amp;str) -&gt; Result&lt;Field, E&gt;
                    where
                        E: de::Error,
                    {
                        match value {
                            &quot;secs&quot; =&gt; Ok(Field::Secs),
                            &quot;nanos&quot; =&gt; Ok(Field::Nanos),
                            _ =&gt; Err(de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }

                deserializer.deserialize_identifier(FieldVisitor)
            }
        }

        struct DurationVisitor;

        impl&lt;'de&gt; Visitor&lt;'de&gt; for DurationVisitor {
            type Value = Duration;

            fn expecting(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {
                formatter.write_str(&quot;struct Duration&quot;)
            }

            fn visit_seq&lt;V&gt;(self, mut seq: V) -&gt; Result&lt;Duration, V::Error&gt;
            where
                V: SeqAccess&lt;'de&gt;,
            {
                let secs = seq.next_element()?
                    .ok_or_else(|| de::Error::invalid_length(0, &amp;self))?;
                let nanos = seq.next_element()?
                    .ok_or_else(|| de::Error::invalid_length(1, &amp;self))?;
                Ok(Duration::new(secs, nanos))
            }

            fn visit_map&lt;V&gt;(self, mut map: V) -&gt; Result&lt;Duration, V::Error&gt;
            where
                V: MapAccess&lt;'de&gt;,
            {
                let mut secs = None;
                let mut nanos = None;
                while let Some(key) = map.next_key()? {
                    match key {
                        Field::Secs =&gt; {
                            if secs.is_some() {
                                return Err(de::Error::duplicate_field(&quot;secs&quot;));
                            }
                            secs = Some(map.next_value()?);
                        }
                        Field::Nanos =&gt; {
                            if nanos.is_some() {
                                return Err(de::Error::duplicate_field(&quot;nanos&quot;));
                            }
                            nanos = Some(map.next_value()?);
                        }
                    }
                }
                let secs = secs.ok_or_else(|| de::Error::missing_field(&quot;secs&quot;))?;
                let nanos = nanos.ok_or_else(|| de::Error::missing_field(&quot;nanos&quot;))?;
                Ok(Duration::new(secs, nanos))
            }
        }

        const FIELDS: &amp;'static [&amp;'static str] = &amp;[&quot;secs&quot;, &quot;nanos&quot;];
        deserializer.deserialize_struct(&quot;Duration&quot;, FIELDS, DurationVisitor)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="discarding-data"><a class="header" href="#discarding-data">Discarding data</a></h1>
<p>The <a href="https://docs.serde.rs/serde/de/struct.IgnoredAny.html"><code>IgnoredAny</code></a> type gives an efficient way of discarding data from a
deserializer.</p>
<p>Think of this like <code>serde_json::Value</code> in that it can be deserialized from
any type, except that it does not store any information about the data that
gets deserialized.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use std::fmt;
use std::marker::PhantomData;

use serde::de::{
    self, Deserialize, DeserializeSeed, Deserializer, Visitor, SeqAccess,
    IgnoredAny,
};
use serde_json::json;

// A seed that can be used to deserialize only the `n`th element of a sequence
// while efficiently discarding elements of any type before or after index `n`.
//
// For example to deserialize only the element at index 3:
//
//    NthElement::new(3).deserialize(deserializer)
pub struct NthElement&lt;T&gt; {
    n: usize,
    marker: PhantomData&lt;fn() -&gt; T&gt;,
}

impl&lt;T&gt; NthElement&lt;T&gt; {
    pub fn new(n: usize) -&gt; Self {
        NthElement {
            n: n,
            marker: PhantomData,
        }
    }
}

impl&lt;'de, T&gt; Visitor&lt;'de&gt; for NthElement&lt;T&gt;
where
    T: Deserialize&lt;'de&gt;,
{
    type Value = T;

    fn expecting(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(formatter, &quot;a sequence in which we care about element {}&quot;, self.n)
    }

    fn visit_seq&lt;V&gt;(self, mut seq: V) -&gt; Result&lt;Self::Value, V::Error&gt;
    where
        V: SeqAccess&lt;'de&gt;,
    {
        // Skip over the first `n` elements.
        for i in 0..self.n {
            // It is an error if the sequence ends before we get to element `n`.
            if seq.next_element::&lt;IgnoredAny&gt;()?.is_none() {
                return Err(de::Error::invalid_length(i, &amp;self));
            }
        }

        // Deserialize the one we care about.
        let nth = seq.next_element()?
                     .ok_or_else(|| de::Error::invalid_length(self.n, &amp;self))?;

        // Skip over any remaining elements in the sequence after `n`.
        while let Some(IgnoredAny) = seq.next_element()? {
            // ignore
        }

        Ok(nth)
    }
}

impl&lt;'de, T&gt; DeserializeSeed&lt;'de&gt; for NthElement&lt;T&gt;
where
    T: Deserialize&lt;'de&gt;,
{
    type Value = T;

    fn deserialize&lt;D&gt;(self, deserializer: D) -&gt; Result&lt;Self::Value, D::Error&gt;
    where
        D: Deserializer&lt;'de&gt;,
    {
        deserializer.deserialize_seq(self)
    }
}

fn main() {
    let array = json!([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]);

    let nth: String = NthElement::new(3).deserialize(&amp;array).unwrap();

    println!(&quot;{}&quot;, nth);
    assert_eq!(nth, array[3]);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transcode-one-format-into-another"><a class="header" href="#transcode-one-format-into-another">Transcode one format into another</a></h1>
<p>The <a href="https://github.com/sfackler/serde-transcode"><code>serde-transcode</code></a> crate
provides functionality to &quot;transcode&quot; from an arbitrary Serde <code>Deserializer</code> to
an arbitrary Serde <code>Serializer</code> without needing to collect the entire input into
an intermediate form in memory. This provides a fully general way to convert any
self-describing Serde data format into any other Serde data format in a
memory-efficient streaming way.</p>
<p>For example you could transcode a stream of JSON data into a stream of CBOR
data, or transcode unformatted JSON into its pretty-printed form.</p>
<p>This example implements the equivalent of Go's
<a href="https://golang.org/pkg/encoding/json/#Compact"><code>json.Compact</code></a> function which
removes insignificant whitespace from a JSON string in a streaming way.</p>
<pre><code class="language-rust noplayground">use std::io;

fn main() {
    // A JSON input with plenty of whitespace.
    let input = r#&quot;
      {
        &quot;a boolean&quot;: true,
        &quot;an array&quot;: [3, 2, 1]
      }
    &quot;#;

    // A JSON deserializer. You can use any Serde Deserializer here.
    let mut deserializer = serde_json::Deserializer::from_str(input);

    // A compacted JSON serializer. You can use any Serde Serializer here.
    let mut serializer = serde_json::Serializer::new(io::stdout());

    // Prints `{&quot;a boolean&quot;:true,&quot;an array&quot;:[3,2,1]}` to stdout.
    // This line works with any self-describing Deserializer and any Serializer.
    serde_transcode::transcode(&amp;mut deserializer, &amp;mut serializer).unwrap();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deserialize-either-a-string-or-a-struct"><a class="header" href="#deserialize-either-a-string-or-a-struct">Deserialize either a string or a struct</a></h1>
<p>The <a href="https://docs.docker.com/compose/compose-file/#/build"><code>docker-compose.yml</code></a>
configuration file has a &quot;build&quot; key which can be either a string or a struct.</p>
<pre><code class="language-yaml">build: ./dir

# --- or ---

build:
  context: ./dir
  dockerfile: Dockerfile-alternate
  args:
    buildno: 1
</code></pre>
<p>The configuration file uses the same pattern in other places as well, typically
where a previously existing string field has been expanded to handle more
complex data.</p>
<p>We can use Rust's
<a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a> trait and
Serde's <code>deserialize_with</code> attribute to handle this pattern in a general way.</p>
<pre><code class="language-rust noplayground">use std::collections::BTreeMap as Map;
use std::fmt;
use std::marker::PhantomData;
use std::str::FromStr;

use serde::{Deserialize, Deserializer};
use serde::de::{self, Visitor, MapAccess};
use void::Void;

fn main() {
    let build_string = &quot;
        build: ./dir
    &quot;;
    let service: Service = serde_yaml::from_str(build_string).unwrap();

    // context=&quot;./dir&quot;
    // dockerfile=None
    // args={}
    println!(&quot;{:?}&quot;, service);

    let build_struct = &quot;
        build:
          context: ./dir
          dockerfile: Dockerfile-alternate
          args:
            buildno: '1'
    &quot;;
    let service: Service = serde_yaml::from_str(build_struct).unwrap();

    // context=&quot;./dir&quot;
    // dockerfile=Some(&quot;Dockerfile-alternate&quot;)
    // args={&quot;buildno&quot;: &quot;1&quot;}
    println!(&quot;{:?}&quot;, service);
}

#[derive(Debug, Deserialize)]
struct Service {
    // The `string_or_struct` function delegates deserialization to a type's
    // `FromStr` impl if given a string, and to the type's `Deserialize` impl if
    // given a struct. The function is generic over the field type T (here T is
    // `Build`) so it can be reused for any field that implements both `FromStr`
    // and `Deserialize`.
    #[serde(deserialize_with = &quot;string_or_struct&quot;)]
    build: Build,
}

#[derive(Debug, Deserialize)]
struct Build {
    // This is the only required field.
    context: String,

    dockerfile: Option&lt;String&gt;,

    // When `args` is not present in the input, this attribute tells Serde to
    // use `Default::default()` which in this case is an empty map. See the
    // &quot;default value for a field&quot; example for more about `#[serde(default)]`.
    #[serde(default)]
    args: Map&lt;String, String&gt;,
}

// The `string_or_struct` function uses this impl to instantiate a `Build` if
// the input file contains a string and not a struct. According to the
// docker-compose.yml documentation, a string by itself represents a `Build`
// with just the `context` field set.
//
// &gt; `build` can be specified either as a string containing a path to the build
// &gt; context, or an object with the path specified under context and optionally
// &gt; dockerfile and args.
impl FromStr for Build {
    // This implementation of `from_str` can never fail, so use the impossible
    // `Void` type as the error type.
    type Err = Void;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        Ok(Build {
            context: s.to_string(),
            dockerfile: None,
            args: Map::new(),
        })
    }
}

fn string_or_struct&lt;'de, T, D&gt;(deserializer: D) -&gt; Result&lt;T, D::Error&gt;
where
    T: Deserialize&lt;'de&gt; + FromStr&lt;Err = Void&gt;,
    D: Deserializer&lt;'de&gt;,
{
    // This is a Visitor that forwards string types to T's `FromStr` impl and
    // forwards map types to T's `Deserialize` impl. The `PhantomData` is to
    // keep the compiler from complaining about T being an unused generic type
    // parameter. We need T in order to know the Value type for the Visitor
    // impl.
    struct StringOrStruct&lt;T&gt;(PhantomData&lt;fn() -&gt; T&gt;);

    impl&lt;'de, T&gt; Visitor&lt;'de&gt; for StringOrStruct&lt;T&gt;
    where
        T: Deserialize&lt;'de&gt; + FromStr&lt;Err = Void&gt;,
    {
        type Value = T;

        fn expecting(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {
            formatter.write_str(&quot;string or map&quot;)
        }

        fn visit_str&lt;E&gt;(self, value: &amp;str) -&gt; Result&lt;T, E&gt;
        where
            E: de::Error,
        {
            Ok(FromStr::from_str(value).unwrap())
        }

        fn visit_map&lt;M&gt;(self, map: M) -&gt; Result&lt;T, M::Error&gt;
        where
            M: MapAccess&lt;'de&gt;,
        {
            // `MapAccessDeserializer` is a wrapper that turns a `MapAccess`
            // into a `Deserializer`, allowing it to be used as the input to T's
            // `Deserialize` implementation. T then deserializes itself using
            // the entries from the map visitor.
            Deserialize::deserialize(de::value::MapAccessDeserializer::new(map))
        }
    }

    deserializer.deserialize_any(StringOrStruct(PhantomData))
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="converting-error-types"><a class="header" href="#converting-error-types">Converting error types</a></h1>
<p>In some situations, values in some format must be contained inside of data in
some other format. For example an <a href="https://www.terraform.io/docs/providers/aws/r/iam_policy.html">IAM policy in Terraform</a> is represented as a
JSON string contained inside of an HCL config.</p>
<p>It would be simple to treat the inner value as just a String, but if we are
going to be manipulating both the inner and outer value it can often be
convenient to serialize and deserialize them all at once.</p>
<p>One occasional stumbling block in such situations is correctly handling errors.
The two formats may (probably do) have different Error types, so some conversion
is necessary.</p>
<p>This example shows a simplified HCL resource containing a simplified IAM policy.
The policy document is represented as a JSON string when serialized.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
struct Resource {
    name: String,

    #[serde(with = &quot;as_json_string&quot;)]
    policy: Policy,
}

#[derive(Serialize, Deserialize)]
struct Policy {
    effect: String,
    action: String,
    resource: String,
}

// Serialize and deserialize logic for dealing with nested values represented as
// JSON strings.
mod as_json_string {
    use serde_json;
    use serde::ser::{Serialize, Serializer};
    use serde::de::{Deserialize, DeserializeOwned, Deserializer};

    // Serialize to a JSON string, then serialize the string to the output
    // format.
    pub fn serialize&lt;T, S&gt;(value: &amp;T, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;
    where
        T: Serialize,
        S: Serializer,
    {
        use serde::ser::Error;
        let j = serde_json::to_string(value).map_err(Error::custom)?;
        j.serialize(serializer)
    }

    // Deserialize a string from the input format, then deserialize the content
    // of that string as JSON.
    pub fn deserialize&lt;'de, T, D&gt;(deserializer: D) -&gt; Result&lt;T, D::Error&gt;
    where
        T: DeserializeOwned,
        D: Deserializer&lt;'de&gt;,
    {
        use serde::de::Error;
        let j = String::deserialize(deserializer)?;
        serde_json::from_str(&amp;j).map_err(Error::custom)
    }
}

fn main() {
    let resource = Resource {
        name: &quot;test_policy&quot;.to_owned(),
        policy: Policy {
            effect: &quot;Allow&quot;.to_owned(),
            action: &quot;s3:ListBucket&quot;.to_owned(),
            resource: &quot;arn:aws:s3:::example_bucket&quot;.to_owned(),
        },
    };

    let y = serde_yaml::to_string(&amp;resource).unwrap();
    println!(&quot;{}&quot;, y);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="date-in-a-custom-format"><a class="header" href="#date-in-a-custom-format">Date in a custom format</a></h1>
<p>This uses the <a href="https://github.com/chronotope/chrono"><code>chrono</code></a> crate to
serialize and deserialize JSON data containing a custom date format. The <code>with</code>
attribute is used to provide the logic for handling the custom representation.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug)]
pub struct StructWithCustomDate {
    // DateTime supports Serde out of the box, but uses RFC3339 format. Provide
    // some custom logic to make it use our desired format.
    #[serde(with = &quot;my_date_format&quot;)]
    pub timestamp: DateTime&lt;Utc&gt;,

    // Any other fields in the struct.
    pub bidder: String,
}

mod my_date_format {
    use chrono::{DateTime, Utc, TimeZone};
    use serde::{self, Deserialize, Serializer, Deserializer};

    const FORMAT: &amp;'static str = &quot;%Y-%m-%d %H:%M:%S&quot;;

    // The signature of a serialize_with function must follow the pattern:
    //
    //    fn serialize&lt;S&gt;(&amp;T, S) -&gt; Result&lt;S::Ok, S::Error&gt;
    //    where
    //        S: Serializer
    //
    // although it may also be generic over the input types T.
    pub fn serialize&lt;S&gt;(
        date: &amp;DateTime&lt;Utc&gt;,
        serializer: S,
    ) -&gt; Result&lt;S::Ok, S::Error&gt;
    where
        S: Serializer,
    {
        let s = format!(&quot;{}&quot;, date.format(FORMAT));
        serializer.serialize_str(&amp;s)
    }

    // The signature of a deserialize_with function must follow the pattern:
    //
    //    fn deserialize&lt;'de, D&gt;(D) -&gt; Result&lt;T, D::Error&gt;
    //    where
    //        D: Deserializer&lt;'de&gt;
    //
    // although it may also be generic over the output types T.
    pub fn deserialize&lt;'de, D&gt;(
        deserializer: D,
    ) -&gt; Result&lt;DateTime&lt;Utc&gt;, D::Error&gt;
    where
        D: Deserializer&lt;'de&gt;,
    {
        let s = String::deserialize(deserializer)?;
        Utc.datetime_from_str(&amp;s, FORMAT).map_err(serde::de::Error::custom)
    }
}

fn main() {
    let json_str = r#&quot;
      {
        &quot;timestamp&quot;: &quot;2017-02-16 21:54:30&quot;,
        &quot;bidder&quot;: &quot;Skrillex&quot;
      }
    &quot;#;

    let data: StructWithCustomDate = serde_json::from_str(json_str).unwrap();
    println!(&quot;{:#?}&quot;, data);

    let serialized = serde_json::to_string_pretty(&amp;data).unwrap();
    println!(&quot;{}&quot;, serialized);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="no-std-support"><a class="header" href="#no-std-support">No-std support</a></h1>
<p>The <code>serde</code> crate has a Cargo feature named <code>&quot;std&quot;</code> that is enabled by default.
In order to use Serde in a no_std context this feature needs to be disabled.
Modify your Serde dependency in Cargo.toml to opt out of enabled-by-default
features.</p>
<pre><code class="language-toml">[dependencies]
serde = { version = &quot;1.0&quot;, default-features = false }
</code></pre>
<p>Be aware that Cargo features are unioned together across your entire dependency
graph. That means if any other crate you depend on has not opted out of Serde's
default features, you will build Serde with the std feature enabled whether or
not your direct dependency on Serde has <code>default-features = false</code>.</p>
<p>In particular, a dependency on <code>serde_json</code> always needs Serde built with std.
If you need JSON support without a standard library, please use
<a href="https://crates.io/crates/serde-json-core"><code>serde-json-core</code></a> instead of <code>serde_json</code>.</p>
<h3 id="derive"><a class="header" href="#derive">Derive</a></h3>
<p>The <code>#[derive(Serialize, Deserialize)]</code> <a href="derive.html">derive macros</a> work just the same in a
no-std crate.</p>
<pre><code class="language-toml">[dependencies]
serde = { version = &quot;1.0&quot;, default-features = false, features = [&quot;derive&quot;] }
</code></pre>
<p>Some deserialization features that require a heap-allocated temporary buffer
will not be available in no-std mode without a memory allocator. In particular
<a href="enum-representations.html">untagged enums</a> cannot be deserialized.</p>
<h3 id="memory-allocation"><a class="header" href="#memory-allocation">Memory allocation</a></h3>
<p>Opting out of the <code>&quot;std&quot;</code> feature of Serde removes support for any standard
library data structures that involve heap memory allocation, including <code>String</code>
and <code>Vec&lt;T&gt;</code>. It also removes some features of <code>derive(Deserialize)</code> including
untagged enums.</p>
<p>You can opt back in to these impls in an unstable way by enabling the <code>&quot;alloc&quot;</code>
Cargo feature. This configuration provides integration for heap-allocated
collections without depending on the rest of the Rust standard library.</p>
<pre><code class="language-toml">[dependencies]
serde = { version = &quot;1.0&quot;, default-features = false, features = [&quot;alloc&quot;] }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="feature-flags"><a class="header" href="#feature-flags">Feature flags</a></h1>
<p>The <code>serde</code> crate defines some <a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-features-section">Cargo features</a> to enable using Serde in a
variety of freestanding environments.</p>
<p>Building Serde with <code>default-features = false</code>, you will receive a stock
<code>no_std</code> Serde with no support for any of the collection types.</p>
<h4 id="--feature-derive"><a class="header" href="#--feature-derive">--feature derive</a></h4>
<p>Provide derive macros for the Serialize and Deserialize traits.</p>
<p>This is behind a feature because the derive macro implementation takes some
extra time to compile.</p>
<h4 id="--feature-std"><a class="header" href="#--feature-std">--feature std</a></h4>
<p><em>This feature is enabled by default.</em></p>
<p>Provide impls for common standard library types like Vec&lt;T&gt; and
HashMap&lt;K, V&gt;. Requires a dependency on the Rust standard library.</p>
<p>See <a href="no-std.html">no-std support</a> for details.</p>
<h4 id="--feature-unstable"><a class="header" href="#--feature-unstable">--feature unstable</a></h4>
<p>Provide impls for types that require unstable functionality. For tracking and
discussion of unstable functionality please refer to <a href="https://github.com/serde-rs/serde/issues/812">serde-rs/serde#812</a>.</p>
<h4 id="--features-alloc"><a class="header" href="#--features-alloc">--features alloc</a></h4>
<p><em>Implies unstable.</em></p>
<p>Provide impls for types in the Rust core allocation and collections library
including String, Box&lt;T&gt;, Vec&lt;T&gt;, and Cow&lt;T&gt;. This is a subset
of std but may be enabled without depending on all of std.</p>
<p>Requires a dependency on the unstable <a href="https://doc.rust-lang.org/alloc/">core allocation library</a>.</p>
<p>See <a href="no-std.html">no-std support</a> for details.</p>
<h4 id="--features-rc"><a class="header" href="#--features-rc">--features rc</a></h4>
<p>Opt into impls for Rc&lt;T&gt; and Arc&lt;T&gt;. Serializing and deserializing
these types does not preserve identity and may result in multiple copies of the
same data. Be sure that this is what you want before enabling this feature.</p>
<p>Serializing a data structure containing reference-counted pointers will
serialize a copy of the inner value of the pointer each time a pointer is
referenced within the data structure. Serialization will not attempt to
deduplicate these repeated data.</p>
<p>Deserializing a data structure containing reference-counted pointers will not
attempt to deduplicate references to the same data. Every deserialized pointer
will end up with a strong count of 1.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
